<style>
  /* Root CSS Variables for Theme Colors and Styling */
  :root {
    --background-color: #bafaff;
    --toolbar-color: #343a40;
    --button-bg-color: #495057;
    --button-hover-bg-color: #218838;
    --label-bg-color: #007bff;
    --label-hover-bg-color: #0056b3;
    --canvas-border: #ccc;
    --canvas-shadow: rgba(0, 0, 0, 0.2);
    --transition-duration: 0.3s;
    --transition-ease: cubic-bezier(0.25, 0.8, 0.25, 1);
    --radius: 8px;
  }

  /* Basic Reset & Global Styles */
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    background-color: var(--background-color);
  }

  /* Toolbar Styling with Flexbox */
  .toolbar {
    padding: 10px 15px;
    background-color: var(--toolbar-color);
    color: #fff;
    display: flex;
    gap: 15px;
    justify-content: center;
    flex-wrap: nowrap;
    width: 100%;
    box-shadow: 0 4px 20px rgba(0, 0, 0, .3);
    border-bottom: 2px solid var(--button-bg-color);
  }

  /* Button & Label Styling */
  button,
  label {
        padding: 10px;
        border: none;
        border-radius: 50px;
        cursor: pointer;
        transition: background-color .3s, transform .3s, box-shadow .3s;
        font-size: 18px;
        text-align: center;
        background-color: #495057
      }

      label {
        background-color: #007bff;
        margin-right: 10px;
      }

      label:hover {
        background-color: #0056b3;
        box-shadow: 0 4px 12px rgba(0, 86, 179, .5)
      }
      
      
        /* Input Field Styling */
    .input-field {
        width: auto; /* Set a fixed width or adjust as needed */
        min-width: 300px; /* Minimum width */
        max-width: 800px;
        padding: 8px; /* Optional: padding for better appearance */
        border: 1px solid var(--canvas-border); /* Optional: border styling */
        border-radius: var(--radius); /* Use variable for consistent radius */
        font-size: 15px; /* Consistent font size */
        transition: border-color var(--transition-duration); /* Transition for border color on focus */
    }
    
    .input-field:focus {
        border-color: var(--label-bg-color); /* Change border color on focus */
        outline: none; /* Remove default outline */
        width: 800px;
    }




  button {
    background-color: pink;
  }

  button:hover {
    background-color: var(--button-hover-bg-color);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(40, 167, 69, .5);
  }

  /* Canvas Container with Flexbox for Centering */
  .canvas-container {
    margin: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 10px;
    position: relative;
  }

  /* Canvas with Smooth Shadows and Rounded Borders */
  #imageCanvas {
    border: 2px solid var(--canvas-border);
    background-color: #fff;
    cursor: crosshair;
    box-shadow: 0 4px 12px var(--canvas-shadow);
    border-radius: var(--radius);
  }

  /* Layer Options Styling with Grid */
  .layer-options {
    display: none;
    gap: 15px;
    margin: 10px 0;
  }

  .layer-options.active {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
    gap: 15px;
  }

  /* Selection Outline */
  .selected {
    outline: 3px solid var(--label-bg-color);
  }

  /* Context Menu Styling with Flexbox */
  .context-menu {
    position: absolute;
    z-index: 100;
    background: #fff;
    border: 1px solid var(--canvas-border);
    border-radius: var(--radius);
    box-shadow: 0 4px 10px rgba(0, 0, 0, .2);
    display: none;
    flex-direction: column;
    padding: 10px;
    
    transition: opacity var(--transition-duration) var(--transition-ease);
  }
  
  .context-menu-group {
      border:0.5px dashed indigo;
      box-shadow: 0 0 0 5px pink;
      border-radius: 50px;
    display: flex;               /* Use Flexbox */
    justify-content: space-between; /* Space items evenly */
    align-items: center;        /* Align items vertically center */
    margin: 5px;       /* Optional: add space below the group */
}

  /* Context Menu Item Styling with Hover Animation */
  .context-menu-item {
    padding: 8px 12px;
    border-radius: 50px;
    cursor: pointer;
    transition: background-color var(--transition-duration) var(--transition-ease);
    display: flex;
    align-items: center;
  }

  .context-menu-item:hover {
    background-color: var(--background-color);
  }

  /* Icons within Context Menu */
  .context-menu-item .icon {
    margin-right: 5px; /* Space between icon and text */
    font-size: 16px; /* Adjust size for better visibility */
  }

  /* Responsive Toolbar */
  @media (max-width: 600px) {
    .toolbar {
      flex-direction: column;
      align-items: flex-start; /* Align items to the left on mobile */
    }
  }

  /* Submenu Styling */
  .submenu {
    display: none;
    position: absolute;
    left: 100%;
    top: 0;
    background: #fff;
    border: 1px solid var(--canvas-border);
    box-shadow: 0 4px 10px rgba(0, 0, 0, .2);
    z-index: 101;
    border-radius: var(--radius);
  }

  .context-menu-item {
    position: relative;
  }

  .context-menu-item:hover .submenu {
    display: block;
  }

  /* Submenu Item Styling with Icons */
  .submenu-item {
    padding: 8px 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    transition: background-color var(--transition-duration) var(--transition-ease);
  }

  .submenu-item:hover {
    background-color: var(--background-color);
  }

  .submenu-item .icon {
    margin-right: 5px; /* Space between icon and text */
    font-size: 16px; /* Size of the icons */
  }

  /* Microinteractions for Panel Opening and Hover Effects */
  .panel-open {
    animation: panelFadeIn var(--transition-duration) var(--transition-ease) forwards;
  }

  /* Keyframes for Smooth Fade-In of Panels */
  @keyframes panelFadeIn {
    0% {
      opacity: 0;
      transform: translateY(-5px);
    }
    100% {
      opacity: 1;
      transform: translateY(0);
    }
  }
  
  
  
  .actions {
    display: flex;                  /* Use Flexbox for layout */
    justify-content: center;        /* Center items */
    margin-top: -20px;               /* Space between the label and icons */
    gap: 19px;                     /* Space between action icons */
}

.action-item {
    display: flex;                 /* Make sure the icon is centered */
    background: black;
    color: white;
    border: hidden;
    box-shadow: 0 0 0 5px pink;
      border-radius: 50px;
    justify-content: center;       /* Center the icon */
    align-items: center;           /* Align icon vertically */
    cursor: pointer;               /* Change cursor on hover */
    padding: 5px;                 /* Optio
  
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/4.5.0/fabric.min.js"></script>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg==" crossorigin="anonymous" referrerpolicy="no-referrer" />




<div class="toolbar">
  <!-- Toolbar Section for Image Operations -->
  <div class="toolbar-section" title="Upload Image">
    <label for="uploadImage">
      <i class="fas fa-upload icon"></i>
    </label>
    <input type="file" id="uploadImage" style="display: none;" accept="image/*">
  </div>

  <div class="toolbar-section" title="Download Image">
    <button id="downloadImage">
      <i class="fas fa-download icon"></i>
    </button>
  </div>

  <!-- Toolbar Section for Undo/Redo -->
  <div class="toolbar-section" title="Undo">
    <button id="undoButton">
      <i class="fas fa-undo icon"></i>
    </button>
  </div>
  <div class="toolbar-section" title="Redo">
    <button id="redoButton">
      <i class="fas fa-redo icon"></i>
    </button>
  </div>

  <!-- Toolbar Section for Caption and Watermark -->
  
  <div class="toolbar-section">
    <input type="text" id="captionInput" placeholder="Caption..." class="input-field">
    <label title="Show Caption">
      
      <input type="checkbox" id="captionCheckbox" class="checkbox" aria-label="Show Caption">
      <i class="far fa-closed-captioning"></i>
    </label>
    <label title="Show Watermark">
      <i class="fas fa-watermark icon"></i>
      <input type="checkbox" id="watermarkCheckbox" class="checkbox" aria-label="Show Watermark">
      <i class="fa-brands fa-wordpress"></i>

    </label>
  </div>

  <!-- Toolbar Section for Zoom Control -->
  <div class="toolbar-section" title="Zoom">
    <input type="range" id="zoomSlider" min="0.5" max="3" step="0.005" value="1">
  </div>
</div>

<!-- Context Menu -->
<div id="contextMenu" class="context-menu">
    
    <div class="context-menu-group">
        <div class="context-menu-item" id="pasteImage" title="Paste">
            <i class="fas fa-clipboard icon"></i>
        </div>
        <div class="context-menu-item" id="deleteLayerContext" title="Delete">
            <i class="fas fa-trash icon"></i>
        </div>
        <div class="context-menu-item" id="duplicateLayer" title="Duplicate">
            <i class="fas fa-copy icon"></i>
        </div>
    </div>
  
  <div class="context-menu-item" id="circularCropButton" title="Circular Crop">
<i class="fas fa-circle-notch"></i>    
    <span>Circular Crop</span>
  </div>
  
  <div class="context-menu-item" id="layersMenu" title="Layers"> 
    <i class="fas fa-layer-group icon"></i>
    <div class="actions">
        <div class="action-item" id="bringToFront" title="Bring to Front">
            <i class="fas fa-arrow-up icon"></i>
        </div>
        <div class="action-item" id="sendToBack" title="Send to Back">
            <i class="fas fa-arrow-down icon"></i>
        </div>
    </div>
    
</div>


<!-- Grouped Flip and Rotate Items -->
<div class="context-menu-group">
    <div class="context-menu-item" id="flipMenu" title="Flip">
        <b>Flip :- </b>
    </div>
    <div class="context-menu-item" id="flipHorizontal" title="Flip Horizontal">
        <i class="fas fa-arrows-alt-h icon"></i>
    </div>
    <div class="context-menu-item" id="flipVertical" title="Flip Vertical">
        <i class="fas fa-arrows-alt-v icon"></i>
    </div>
    <div class="context-menu-item" id="rotateLayer" title="Rotate">
        <i class="fas fa-undo-alt icon"></i>
    </div>
</div>


  
  
  
  <div class="context-menu-group">
        <div class="context-menu-item" id="alignMenu" title="Change Alignment">
             <b>Align :- </b>
        </div>
       
        <div class="context-menu-item" id="alignLeft" title="Align Left">
            <i class="fas fa-align-left icon"></i>
        </div>
        <div class="context-menu-item" id="alignCenter" title="Align Center">
            <i class="fas fa-align-center icon"></i>
        </div>
        <div class="context-menu-item" id="alignRight" title="Align Right">
            <i class="fas fa-align-right icon"></i>
        </div>
        <div class="context-menu-item" id="resetTransform" title="Reset Alignment">
            <i class="fa fa-refresh"></i>
             <!-- Changed icon for clarity -->
        </div>
    </div>
  
  <div class="context-menu-item" id="setAsBackground" title="Set as Background">
    <i class="fas fa-image icon"></i>
    <span>Set as Background</span>
  </div>
  <div class="context-menu-item" id="detachBackground" style="display:none" title="Detach Background">
    <i class="fas fa-object-group icon"></i>
    <span>Detach Background</span>
  </div>

  

  <div class="context-menu-item" id="filtersMenu">Filters
    <div class="submenu" id="submenu">
      <div class="submenu-item" id="grayscaleFilter">
        <i class="fas fa-paint-brush icon"></i>
        <span>Grayscale</span>
      </div>
      <div class="submenu-item">
        <i class="fas fa-sun icon"></i>
        <span>Brightness</span>
        <input type="range" id="brightnessFilter" min="-50" max="50" value="0">
      </div>
      <div class="submenu-item">
        <i class="fas fa-adjust icon"></i>
        <span>Contrast</span>
        <input type="range" id="contrastFilter" min="-50" max="50" value="0">
      </div>
      <div class="submenu-item">
        <i class="fas fa-paint-brush icon"></i>
        <span>Saturation</span>
        <input type="range" id="saturationFilter" min="-100" max="100" value="0">
      </div>
    </div>
  </div>
</div>

<!-- Canvas Container -->
<div class="canvas-container" id="canvasContainer">
  <canvas id="imageCanvas" width="800" height="418"></canvas>
</div>

    <script>
      const canvas = new fabric.Canvas('imageCanvas', {
        preserveObjectStacking: true
      });
      let isCropping = false;
      let cropCircle;
      let history = [];
      let historyIndex = -1;
      // Load image into canvas and center it

      
      document.getElementById('pasteImage').addEventListener('click', function() {
        navigator.clipboard.read().then(items => {
          for (const item of items) {
            if (item.types.includes('image/png')) {
              item.getType('image/png').then(blob => {
                const img = new Image();
                img.src = URL.createObjectURL(blob);
                img.onload = function() {
                  loadImage(img); // Assuming loadImage function is already handling adding image to canvas
                };
              });
            }
          }
        });
        contextMenu.style.display = 'none'; // Hide context menu after action
      });
      document.getElementById('uploadImage').addEventListener('change', async function (e) {
    if (e.target.files.length === 0) {
        alert('Please select an image file.');
        return;
    }

    try {
        const reader = new FileReader();
        reader.onload = function (event) {
            const img = new Image();
            img.src = event.target.result;

            img.onload = function () {
                try {
                    loadImage(img); // Existing function to add the image to the canvas
                } catch (error) {
                    console.error('Error adding image to canvas:', error);
                    alert('Failed to add image to canvas. Please try again.');
                }
            };

            img.onerror = function () {
                console.error('Image failed to load');
                alert('Image format not supported or corrupted.');
            };
        };
        reader.onerror = function () {
            console.error('Error reading file');
            alert('Failed to read the selected file.');
        };
        reader.readAsDataURL(e.target.files[0]);
    } catch (error) {
        console.error('Error uploading image:', error);
        alert('An unexpected error occurred while uploading the image.');
    }
});

      // Handle drag and drop functionality
      const canvasContainer = document.getElementById('canvasContainer');
      canvasContainer.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';
      });
      canvasContainer.addEventListener('drop', function(e) {
        e.preventDefault();
        const files = e.dataTransfer.files;
        if (files.length > 0 && files[0].type.startsWith('image/')) {
          const reader = new FileReader();
          reader.onload = function(event) {
            const img = new Image();
            img.src = event.target.result;
            img.onload = function() {
              loadImage(img);
            };
          };
          reader.readAsDataURL(files[0]);
        } else {
          alert('Please drop a valid image file.');
        }
      });
      // Get context menu element
      const contextMenu = document.getElementById('contextMenu');
      // Handle right-click on canvas
      // Hide context menu on left click or anywhere else
      document.addEventListener('click', function() {
        contextMenu.style.display = 'none';
      });
      // Duplicate layer functionality
      document.getElementById('duplicateLayer').addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          const clonedObject = fabric.util.object.clone(activeObject);
          clonedObject.set({
            left: activeObject.left + 10, // Offset to prevent overlap
            top: activeObject.top + 10,
            selectable: true,
          });
          canvas.add(clonedObject);
          addHistory();
        }
        contextMenu.style.display = 'none'; // Hide context menu
      });
      // Delete layer functionality
      document.getElementById('deleteLayerContext').addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          canvas.remove(activeObject);
          addHistory();
        }
        contextMenu.style.display = 'none'; // Hide context menu
      });
      // Bring to front functionality
      document.getElementById('bringToFront').addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          canvas.bringToFront(activeObject);
          addHistory();
        }
        contextMenu.style.display = 'none'; // Hide context menu
      });
      // Send to back functionality
      document.getElementById('sendToBack').addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          canvas.sendToBack(activeObject);
          addHistory();
        }
        contextMenu.style.display = 'none'; // Hide context menu
      });
      // Handle double click to crop
      canvas.on('mouse:dblclick', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject && activeObject.type === 'image') {
          enterCropMode(activeObject);
        }
      });
      // Enter Crop Mode
      function enterCropMode(image) {
        if (isCropping) return; // Already cropping
        isCropping = true;
        // Create a cropping rectangle over the image
        cropRect = new fabric.Rect({
          left: image.left,
          top: image.top,
          width: image.width * image.scaleX,
          height: image.height * image.scaleY,
          fill: 'rgba(0,0,0,0.3)',
          hasBorders: true,
          hasControls: true,
          selectable: true,
        });
        canvas.add(cropRect);
        canvas.setActiveObject(cropRect);
        canvas.renderAll();
        // Add crop and cancel buttons
        const cropButton = document.createElement('button');
        cropButton.innerText = 'Crop';
        cropButton.style.position = 'absolute';
        cropButton.style.top = '10px';
        cropButton.style.right = '10px';
        document.body.appendChild(cropButton);
        cropButton.addEventListener('click', function() {
          cropImage(image);
          document.body.removeChild(cropButton); // Remove crop button after action
        });
      }
      // Crop the image based on cropping rectangle
      function cropImage(image) {
        if (!cropRect) return;
        const croppedLeft = cropRect.left - image.left;
        const croppedTop = cropRect.top - image.top;
        const croppedWidth = cropRect.width * cropRect.scaleX;
        const croppedHeight = cropRect.height * cropRect.scaleY;
        const croppedCanvas = document.createElement('canvas');
        croppedCanvas.width = croppedWidth;
        croppedCanvas.height = croppedHeight;
        const croppedCtx = croppedCanvas.getContext('2d');
        croppedCtx.drawImage(image._element, croppedLeft / image.scaleX, croppedTop / image.scaleY, croppedWidth / image.scaleX, croppedHeight / image.scaleY, 0, 0, croppedWidth, croppedHeight);
        const croppedImg = new Image();
        croppedImg.src = croppedCanvas.toDataURL();
        croppedImg.onload = function() {
          const newImage = new fabric.Image(croppedImg);
          newImage.set({
            left: image.left,
            top: image.top,
            scaleX: image.scaleX,
            scaleY: image.scaleY,
            hasControls: true,
            hasBorders: true,
          });
          canvas.remove(image); // Remove original image
          canvas.add(newImage); // Add cropped image
          canvas.setActiveObject(newImage);
          canvas.renderAll();
          addHistory(); // Add to history after cropping
        };
        canvas.remove(cropRect); // Remove cropping rectangle after cropping
        isCropping = false;
        cropRect = null;
      }
      // Circular Crop Button
      document.getElementById('circularCropButton').addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject && activeObject.type === 'image') {
          enterCircularCropMode(activeObject);
        }
      });
      // Enter Circular Crop Mode
      function enterCircularCropMode(image) {
        if (isCropping) return; // Already cropping
        isCropping = true;
        // Create a cropping circle over the image
        const centerX = image.left + (image.width * image.scaleX) / 2;
        const centerY = image.top + (image.height * image.scaleY) / 2;
        const radius = Math.min(image.width * image.scaleX, image.height * image.scaleY) / 2;
        cropCircle = new fabric.Circle({
          left: centerX - radius,
          top: centerY - radius,
          radius: radius,
          fill: 'rgba(0,0,0,0.3)',
          hasBorders: true,
          hasControls: true,
          selectable: true,
        });
        canvas.add(cropCircle);
        canvas.setActiveObject(cropCircle);
        canvas.renderAll();
        // Add crop and cancel buttons
        const cropButton = document.createElement('button');
        cropButton.innerText = 'Crop';
        cropButton.style.position = 'absolute';
        cropButton.style.top = '10px';
        cropButton.style.right = '10px';
        document.body.appendChild(cropButton);
        cropButton.addEventListener('click', function() {
          cropCircleImage(image);
          document.body.removeChild(cropButton); // Remove crop button after action
        });
      }
      // Crop the image based on cropping circle
      function cropCircleImage(image) {
        if (!cropCircle) return;
        const cropRadius = cropCircle.radius * cropCircle.scaleX; // Consider circle scaling
        const circleCenterX = cropCircle.left + cropRadius; // X center of the crop circle
        const circleCenterY = cropCircle.top + cropRadius; // Y center of the crop circle
        const croppedCanvas = document.createElement('canvas');
        const croppedCtx = croppedCanvas.getContext('2d');
        // Set the canvas size to match the diameter of the crop circle
        const diameter = cropRadius * 2;
        croppedCanvas.width = diameter;
        croppedCanvas.height = diameter;
        // Draw a circular clipping path
        croppedCtx.beginPath();
        croppedCtx.arc(cropRadius, cropRadius, cropRadius, 0, Math.PI * 2, false);
        croppedCtx.clip();
        // Calculate image offset within the crop circle
        const imageLeftOffset = (circleCenterX - cropRadius - image.left) / image.scaleX;
        const imageTopOffset = (circleCenterY - cropRadius - image.top) / image.scaleY;
        // Draw the image into the clipped circular area
        croppedCtx.drawImage(image._element, imageLeftOffset, // Source X
          imageTopOffset, // Source Y
          diameter / image.scaleX, // Source Width
          diameter / image.scaleY, // Source Height
          0, // Destination X
          0, // Destination Y
          diameter, // Destination Width
          diameter // Destination Height
        );
        // Create a new fabric image with the cropped circular content
        const croppedImg = new Image();
        croppedImg.src = croppedCanvas.toDataURL();
        croppedImg.onload = function() {
          const newImage = new fabric.Image(croppedImg, {
            left: image.left + (circleCenterX - cropRadius - image.left), // Correct X position
            top: image.top + (circleCenterY - cropRadius - image.top), // Correct Y position
            hasControls: true,
            hasBorders: true,
            selectable: true
          });
          // Replace the original image with the cropped circular image
          canvas.remove(image);
          canvas.add(newImage);
          canvas.setActiveObject(newImage);
          canvas.renderAll();
          addHistory(); // Add to history after cropping
        };
        // Remove the crop circle and reset cropping state
        canvas.remove(cropCircle);
        cropCircle = null;
        isCropping = false;
      }
      
      
      
      // Undo Functionality
      document.getElementById('undoButton').addEventListener('click', function() {
        if (historyIndex > 0) {
          historyIndex--;
          restoreCanvasState(history[historyIndex]);
        }
      });
      // Redo Functionality
      document.getElementById('redoButton').addEventListener('click', function() {
        if (historyIndex < history.length - 1) {
          historyIndex++;
          restoreCanvasState(history[historyIndex]);
        }
      });
      // Helper function to restore canvas state
      function restoreCanvasState(state) {
        canvas.clear();
        state.forEach(function(item) {
          // Re-create the fabric objects from the state
          const obj = fabric.util.enlivenObjects([item], function(enlivedObjects) {
            enlivedObjects.forEach(function(newObj) {
              canvas.add(newObj);
            });
            canvas.renderAll();
          });
        });
      }
      // Add to history function
      function addHistory() {
        if (historyIndex < history.length - 1) {
          // Limit history size
          history = history.slice(0, historyIndex + 1);
        }
        // Clone the current canvas state
        const currentState = canvas.getObjects().map(function(obj) {
          return fabric.util.object.clone(obj); // Clone objects for history
        });
        history.push(currentState);
        historyIndex++;
        // Limit history length (for example, to the last 50 states)
        if (history.length > 50) {
          history.shift(); // Remove the oldest state
          historyIndex--; // Adjust the index accordingly
        }
      }


      
      // Flip Horizontally
document.getElementById('flipHorizontal').addEventListener('click', function() {
    const activeObject = canvas.getActiveObject();
    if (activeObject) {
        // Flip the object
        activeObject.set({
            scaleX: -activeObject.scaleX // Flip the horizontal scale
        });
        activeObject.setCoords(); // Update coordinates to ensure proper resizing
        canvas.renderAll(); // Render the canvas
        addHistory(); // Add to history after flipping
    }
    contextMenu.style.display = 'none'; // Hide context menu
});

// Flip Vertically
document.getElementById('flipVertical').addEventListener('click', function() {
    const activeObject = canvas.getActiveObject();
    if (activeObject) {
        // Flip the object
        activeObject.set({
            scaleY: -activeObject.scaleY // Flip the vertical scale
        });
        activeObject.setCoords(); // Update coordinates to ensure proper resizing
        canvas.renderAll(); // Render the canvas
        addHistory(); // Add to history after flipping
    }
    contextMenu.style.display = 'none'; // Hide context menu
});

      
      // Rotate Layer
      document.getElementById('rotateLayer').addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          activeObject.angle = (activeObject.angle + 90) % 360; // Rotate the object by 90 degrees
          canvas.renderAll();
          addHistory(); // Add to history after rotating
        }
        contextMenu.style.display = 'none'; // Hide context menu
      });
      document.getElementById('resetTransform').addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          activeObject.set({
            scaleX: 1,
            scaleY: 1,
            angle: 0,
            left: 0,
            top: 0,
          });
          addHistory();
          canvas.renderAll();
        }
      });
      document.getElementById('alignLeft').addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          activeObject.set('left', 0);
          canvas.renderAll();
          addHistory();
        }
      });
      document.getElementById('alignCenter').addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          activeObject.set('left', (canvas.width - activeObject.width) / 2);
          canvas.renderAll();
          addHistory();
        }
      });
      document.getElementById('alignRight').addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          activeObject.set('left', canvas.width - activeObject.width);
          canvas.renderAll();
          addHistory();
        }
      });
      
      
      
      
      
      // Function to load an image and scale it properly onto the canvas


function loadImage(img) {
  const imgInstance = new fabric.Image(img);
  
  // Calculate scaling factor based on canvas dimensions
  const canvasAspect = canvas.width / canvas.height;
  const imgAspect = img.width / img.height;

  let scaleFactor;
  if (canvasAspect > imgAspect) {
    scaleFactor = canvas.height / img.height; // Fit to height
  } else {
    scaleFactor = canvas.width / img.width; // Fit to width
  }

  imgInstance.set({
    left: (canvas.width - img.width * scaleFactor) / 2, // Center horizontally
    top: (canvas.height - img.height * scaleFactor) / 2, // Center vertically
    scaleX: scaleFactor,
    scaleY: scaleFactor,
    hasControls: true,
    hasBorders: true,
    selectable: true,
  });

  canvas.add(imgInstance).setActiveObject(imgInstance);
  canvas.renderAll();
  addHistory(); // Add to history after adding an image
  updateLayerOptions(true);
  imgInstance.dispose();
}





// Function to create a Web Worker for size calculation
const createWorker = () => {
    const workerScript = `
        self.onmessage = async function(e) {
            const { dataUrl } = e.data;
            try {
                const response = await fetch(dataUrl);
                const blob = await response.blob();
                postMessage({ size: blob.size });
            } catch (error) {
                postMessage({ error: error.message });
            }
        };
    `;
    const blob = new Blob([workerScript], { type: "application/javascript" });
    return new Worker(URL.createObjectURL(blob));
};

// Enhanced adaptive binary search for best quality within size limit
const adaptiveBinarySearch = async (canvas, maxFileSize, minQuality = 0.1, maxQuality = 1.0) => {
    let lower = minQuality;
    let upper = maxQuality;
    let resultQuality = minQuality;

    while (upper - lower > 0.01) {
        const midQuality = (lower + upper) / 2;
        const dataUrl = canvas.toDataURL("image/webp", midQuality);
        
        const size = await new Promise((resolve, reject) => {
            const worker = createWorker();
            worker.onmessage = (e) => {
                if (e.data.error) {
                    reject(new Error(e.data.error));
                } else {
                    resolve(e.data.size);
                }
                worker.terminate();
            };
            worker.onerror = (error) => {
                reject(error);
            };
            worker.postMessage({ dataUrl });
        }).catch(() => 0);

        if (size <= maxFileSize) {
            resultQuality = midQuality; // Save the optimal quality
            lower = midQuality;
        } else {
            upper = midQuality;
        }
    }
    return resultQuality;
};

// Function to compress image to highest quality under size limit
const compressImage = async (canvas, maxFileSize = 75 * 1024) => {
    const optimalQuality = await adaptiveBinarySearch(canvas, maxFileSize);
    return canvas.toDataURL("image/webp", optimalQuality);
};

// Event listener for downloading the image
document.getElementById('downloadImage').addEventListener('click', async function() {
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = 1200; // Desired resolution
    tempCanvas.height = 628;  // Desired resolution
    const ctx = tempCanvas.getContext('2d');

    const imageData = canvas.toDataURL("image/png", 1.0);
    const img = new Image();
    img.onload = async function() {
        // Set high-quality image smoothing
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high"; // Improved quality setting

        // Draw image with high-quality settings
        ctx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);

        // Optional: Add caption and watermark
        const caption = document.getElementById('captionInput').value;
        if (document.getElementById('captionCheckbox').checked && caption) {
            addCaption(ctx, tempCanvas, caption);
        }
        if (document.getElementById('watermarkCheckbox').checked) {
            addWatermark(ctx, tempCanvas);
        }

        // Compress and download the image
        const downloadDataUrl = await compressImage(tempCanvas, 50 * 1024); // Adjusted max file size
        const downloadLink = document.createElement('a');
        downloadLink.href = downloadDataUrl;
        downloadLink.download = `VvipTimes_${caption.replace(/\s+/g, '_')}.webp`;
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
        resetCanvasState();
    };
    img.src = imageData;
});



// Caption addition
function addCaption(ctx, canvas, caption) {
  ctx.font = "500 22px Arial";
  ctx.fillStyle = "black";
  ctx.globalAlpha = 0.7;
  const textMetrics = ctx.measureText(caption);
  const textHeight = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent;
  
  // Create a rounded rectangle background for the caption
  ctx.beginPath();
  ctx.roundRect(0, canvas.height - (textHeight + 10), canvas.width, textHeight + 10, 15);
  ctx.fill();
  
  // Draw the caption text
  ctx.globalAlpha = 1; // Reset alpha for text
  ctx.fillStyle = "white";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(caption, canvas.width / 2, canvas.height - (textHeight / 2 + 5));
}

// Watermark addition
function addWatermark(ctx, canvas) {
  const padding = 5;
  ctx.font = "700 24px Arial";
  ctx.fillStyle = "#010642";
  ctx.globalAlpha = 0.77;
  
  // Create a rounded rectangle for the watermark background
  ctx.beginPath();
  ctx.roundRect(canvas.width - 150 - padding, padding, 150, 36, 50);
  ctx.fill();
  
  // Draw the watermark text
  ctx.globalAlpha = 1; // Reset alpha for text
  ctx.fillStyle = "white";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("VvipTimes", canvas.width - 75 - padding, padding + 18);
}








      
      

      // Get submenu and filter item
      // Get references to the sliders
      const brightnessSlider = document.getElementById('brightnessFilter');
      const contrastSlider = document.getElementById('contrastFilter');
      const saturationSlider = document.getElementById('saturationFilter');
      const grayscaleButton = document.getElementById('grayscaleFilter');
      // Function to apply the filters
      function applyFilters() {
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          activeObject.filters = [];
          // Apply Brightness Filter
          const brightnessValue = brightnessSlider.value / 100; // Normalize value between -1 and 1
          const brightnessFilter = new fabric.Image.filters.Brightness({
            brightness: brightnessValue
          });
          activeObject.filters.push(brightnessFilter);
          // Apply Contrast Filter
          const contrastValue = contrastSlider.value / 100; // Normalize value between -1 and 1
          const contrastFilter = new fabric.Image.filters.Contrast({
            contrast: contrastValue
          });
          activeObject.filters.push(contrastFilter);
          // Apply Saturation Filter
          const saturationValue = saturationSlider.value / 100; // Normalize value between -1 and 1
          const saturationFilter = new fabric.Image.filters.Saturation({
            saturation: saturationValue
          });
          activeObject.filters.push(saturationFilter);
          // Re-apply all filters and render the canvas
          activeObject.applyFilters();
          canvas.renderAll();
        }
      }
      // Add event listeners to the sliders to apply filters dynamically
      brightnessSlider.addEventListener('input', applyFilters);
      contrastSlider.addEventListener('input', applyFilters);
      saturationSlider.addEventListener('input', applyFilters);
      // Grayscale Filter Button
      grayscaleButton.addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          activeObject.filters = [];
          const grayscaleFilter = new fabric.Image.filters.Grayscale();
          activeObject.filters.push(grayscaleFilter);
          // Apply Grayscale filter and render the canvas
          activeObject.applyFilters();
          canvas.renderAll();
          addHistory();
        }
      });
      // Listen for keydown events on the entire document
      document.addEventListener('keydown', function(event) {
        // Check if the key pressed is either Backspace (keyCode 8) or Delete (keyCode 46)
        if (event.key === 'Backspace' || event.key === 'Delete') {
          // Prevent the default browser behavior (like navigating back in case of Backspace)
          event.preventDefault();
          // Get the currently active object on the canvas
          const activeObject = canvas.getActiveObject();
          // If there is an active object, remove it from the canvas
          if (activeObject) {
            canvas.remove(activeObject);
            addHistory();
            canvas.renderAll(); // Re-render the canvas
          }
        }
      });
      let backgroundImage = null;
      document.getElementById('setAsBackground').addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject && activeObject.type === 'image') {
          const img = new Image();
          img.src = activeObject.toDataURL(); // Get the image data URL
          img.onload = function() {
            const canvasWidth = 800; // dynamic canvas width
            const canvasHeight = 418; // dynamic canvas height
            const outputWidth = 1200; // output image width
            const outputHeight = 628; // output image height
            const imgRatio = img.width / img.height; // Image aspect ratio
            const canvasRatio = canvasWidth / canvasHeight; // Canvas aspect ratio
            const outputRatio = outputWidth / outputHeight; // Output image aspect ratio
            let drawWidth, drawHeight;
            // Adjust dimensions based on aspect ratios
            if (imgRatio > outputRatio) {
              // Image is wider compared to the output canvas
              drawWidth = outputWidth;
              drawHeight = outputWidth / imgRatio;
            } else {
              // Image is taller compared to the output canvas
              drawHeight = outputHeight;
              drawWidth = outputHeight * imgRatio;
            }
            // Scale the canvas to match output image size
            canvas.setDimensions({
              width: canvasWidth,
              height: canvasHeight
            });
            // Set the image on the canvas with accurate scaling and center alignment
            canvas.setBackgroundImage(img.src, canvas.renderAll.bind(canvas), {
              originX: 'left', // Align from the left
              originY: 'top', // Align from the top
              left: (canvasWidth - drawWidth) / 2, // Center horizontally
              top: (canvasHeight - drawHeight) / 2, // Center vertically
              scaleX: drawWidth / img.width, // Scale to fit width
              scaleY: drawHeight / img.height // Scale to fit height
            });
            // Store the original image as background
            backgroundImage = activeObject;
            // Remove the image object from the canvas after setting it as background
            canvas.remove(activeObject);
            // Hide the "Set as Background" and show "Detach Background"
            document.getElementById('setAsBackground').style.display = 'none';
            document.getElementById('detachBackground').style.display = 'block';
            addHistory(); // Add this action to history for undo functionality
          };
        }
        contextMenu.style.display = 'none'; // Hide the context menu after action
      });
      
      
      function detachImageFromCanvas(image) {
    if (image) {
        canvas.remove(image);
        canvas.dispose(); // Dispose of unused canvas objects to free memory
        canvas.renderAll();
    }
}

      
      
      
      document.getElementById('detachBackground').addEventListener('click', function() {
  if (backgroundImage) {
    // Remove the background image from the canvas
    canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas));
    
    // Create a new Image instance from the original image's data URL
    const originalImg = new Image();
    originalImg.src = backgroundImage.toDataURL(); // Get the original image data URL

    originalImg.onload = function() {
      // Create an image instance for fabric.js
      const imgInstance = new fabric.Image(originalImg, {
        left: (canvas.width - originalImg.width) / 2, // Center the image horizontally
        top: (canvas.height - originalImg.height) / 2, // Center the image vertically
        selectable: true,
        hasControls: true, // Make sure the image is selectable and has controls
        hasBorders: true
      });
      
      // Add the image back to the canvas
      canvas.add(imgInstance);
      canvas.setActiveObject(imgInstance); // Set the newly added image as active
      canvas.renderAll(); // Refresh the canvas

      // Clear the reference to the background image
      backgroundImage = null;

      // Hide "Detach Background" and show "Set as Background"
      document.getElementById('setAsBackground').style.display = 'block';
      document.getElementById('detachBackground').style.display = 'none';

      // Add this action to history for undo functionality
      addHistory();
    };
  }
  contextMenu.style.display = 'none'; // Hide the context menu after action
});


      canvasContainer.addEventListener('contextmenu', function(e) {
        e.preventDefault(); // Prevent default context menu
        const activeObject = canvas.getActiveObject();
        const canvasHasObjects = canvas.getObjects().length > 0; // Check if canvas has any objects
        const hasBackgroundImage = !!canvas.backgroundImage; // Check if a background image is set
        // Clear previous context menu state
        document.getElementById('pasteImage').style.display = 'none';
        document.getElementById('setAsBackground').style.display = 'none';
        document.getElementById('detachBackground').style.display = 'none';
        document.getElementById('layersMenu').style.display = 'none';
        document.getElementById('flipMenu').style.display = 'none';
        document.getElementById('rotateLayer').style.display = 'none';
        document.getElementById('resetTransform').style.display = 'none';
        document.getElementById('alignMenu').style.display = 'none';
        document.getElementById('filtersMenu').style.display = 'none';
        document.getElementById('circularCropButton').style.display = 'none';
        // If the canvas has no objects, only show the "Paste" option
        if (!canvasHasObjects) {
          document.getElementById('pasteImage').style.display = 'block';
        }
        // If an image is selected, show the full context menu
        if (activeObject && activeObject.type === 'image') {
          document.getElementById('pasteImage').style.display = 'block'; // Always show paste
          document.getElementById('setAsBackground').style.display = 'block'; // Show "Set as Background" for images
          document.getElementById('layersMenu').style.display = 'block';
          document.getElementById('flipMenu').style.display = 'block';
          document.getElementById('rotateLayer').style.display = 'block';
          document.getElementById('resetTransform').style.display = 'block';
          document.getElementById('alignMenu').style.display = 'block';
          document.getElementById('filtersMenu').style.display = 'block';
          document.getElementById('circularCropButton').style.display = 'block';
        }
        // Show "Detach Background" option only if a background image has been set
        if (hasBackgroundImage) {
          document.getElementById('detachBackground').style.display = 'block';
        }
        // Position the context menu at the point of the right-click
        contextMenu.style.left = `${e.clientX}px`;
        contextMenu.style.top = `${e.clientY}px`;
        contextMenu.style.display = 'block'; // Show the context menu
      });
      
      
      
      
      
      
      
      
      
      
    
    
    
    
    
    
    
    
    
    // Configuration Constants
const CORNER_COLOR = 'rgba(75, 0, 130, 0.9)';
const CORNER_STROKE_COLOR = 'indigo';
const CORNER_STYLE = 'circle';
const CORNER_STROKE_WIDTH = 2;

const CORNER_SIZE = 20; // Size of corner handles
const SHADOW_COLOR = 'rgba(75, 0, 130, 0.9)';
const SHADOW_BLUR = 30;
const SHADOW_OFFSET_X = 5;
const SHADOW_OFFSET_Y = 5;

const DASHED_BORDER = [6, 8]; // Dashed border effect

// Extend Fabric.js to customize corner behavior
fabric.Object.prototype.cornerColor = CORNER_COLOR;
fabric.Object.prototype.cornerStrokeColor = CORNER_STROKE_COLOR;
fabric.Object.prototype.cornerStyle = CORNER_STYLE;
fabric.Object.prototype.cornerStrokeWidth = CORNER_STROKE_WIDTH;

// Customize the corner size and position
fabric.Object.prototype.corners = {
    tl: { x: -12, y: -12 },  // Top Left
    tr: { x: 12, y: -12 },   // Top Right
    bl: { x: -12, y: 12 },   // Bottom Left
    br: { x: 12, y: 12 }     // Bottom Right
};

// Function to customize corner rendering
fabric.Object.prototype._renderCorners = function(ctx) {
    ctx.save();
    ctx.fillStyle = this.cornerColor;
    ctx.strokeStyle = this.cornerStrokeColor;
    ctx.lineWidth = this.cornerStrokeWidth;

    // Draw circular corners
    Object.entries(this.corners).forEach(([key, { x, y }]) => {
        ctx.beginPath();
        ctx.arc(this.left + x + this.width / 2, this.top + y + this.height / 2, CORNER_SIZE, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.closePath();
    });

    ctx.restore();
};

// Function to set common styles for images
function setImageStyles(obj, styles) {
    if (!obj || !obj.type === 'image') return; // Validate object

    obj.set({
        borderColor: styles.borderColor || '',
        borderDashArray: styles.borderDashArray || null,
        cornerColor: styles.cornerColor || '',
        cornerStrokeColor: styles.cornerStrokeColor || '',
        shadow: styles.shadow || null,
        opacity: styles.opacity !== undefined ? styles.opacity : 1,
        selectable: true,
        evented: true,
        padding: 3,
    });
}

// Enhance visual feedback on selection
function enhanceSelectedImages() {
    const activeObjects = canvas.getActiveObjects();

    activeObjects.forEach((obj) => {
        if (obj.type === 'image') {
            setImageStyles(obj, {
                borderColor: 'rgba(75, 0, 130, 0.9)', // Selection border color
                borderDashArray: DASHED_BORDER, // Dashed border effect
                cornerColor: 'rgba(75, 0, 130, 1)', // Brighter corner color
                shadow: new fabric.Shadow({
                    color: SHADOW_COLOR, 
                    blur: SHADOW_BLUR,
                    offsetX: SHADOW_OFFSET_X,
                    offsetY: SHADOW_OFFSET_Y
                })
            });
        }
    });

    canvas.renderAll(); // Refresh the canvas to apply styles
}

// Reset styles when selection is cleared
canvas.on('selection:cleared', function() {
    canvas.getObjects().forEach((obj) => {
        if (obj.type === 'image') {
            setImageStyles(obj, {
                borderColor: '',
                borderDashArray: null, // Reset dashed border
                cornerColor: '',
                cornerStrokeColor: '',
                shadow: null,
                opacity: 1, // Reset opacity
            });
        }
    });

    canvas.renderAll(); // Refresh the canvas
});

// Hover effect for images
canvas.on('mouse:over', function(event) {
    if (event.target && event.target.type === 'image') {
        event.target.set('shadow', new fabric.Shadow({
            color: SHADOW_COLOR, // Shadow color on hover
            blur: 25,
            offsetX: 0,
            offsetY: 0,
        }));
        canvas.renderAll(); // Refresh canvas
    }
});

// Remove shadow on mouse out
canvas.on('mouse:out', function(event) {
    if (event.target && event.target.type === 'image') {
        event.target.set('shadow', null); // Remove shadow on mouse out
        canvas.renderAll(); // Refresh canvas
    }
});

// Apply enhancements on selection
canvas.on('selection:created', enhanceSelectedImages);
canvas.on('selection:updated', enhanceSelectedImages);





    // Function to zoom the canvas container
function zoomCanvas(scale) {
    const canvasContainer = document.getElementById('canvasContainer'); // Adjust this if your container ID is different
    canvasContainer.style.transform = `scale(${scale})`;
    canvasContainer.style.transformOrigin = 'top left'; // Ensure scaling happens from the top left corner
}

// Event listener for the zoom slider
document.getElementById('zoomSlider').addEventListener('input', function(event) {
    const scaleValue = event.target.value; // Get the current value of the slider
    zoomCanvas(scaleValue); // Call the zoom function with the slider value
});

    
    
    
      
      
      
    </script>
