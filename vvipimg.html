<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Image Editor with Fabric.js</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: #f0f2f5
      }

      .toolbar {
        padding: 10px 15px;
        background-color: #343a40;
        color: #fff;
        display: flex;
        gap: 15px;
        justify-content: center;
        flex-wrap: nowrap;
        width: 100%;
        box-shadow: 0 4px 20px rgba(0, 0, 0, .3);
        border-bottom: 2px solid #495057
      }

      button,
      label {
        padding: 8px 10px;
        border: none;
        border-radius: 50px;
        cursor: pointer;
        transition: background-color .3s, transform .3s, box-shadow .3s;
        font-size: 15px;
        text-align: center;
        background-color: #495057
      }

      label {
        background-color: #007bff
      }

      label:hover {
        background-color: #0056b3;
        box-shadow: 0 4px 12px rgba(0, 86, 179, .5)
      }

      button {
        background-color: #28a745
      }

      button:hover {
        background-color: #218838;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(40, 167, 69, .5)
      }

      .canvas-container {
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 10px;
        position: relative
      }

      #imageCanvas {
        border: 2px solid #ccc;
        background-color: #fff;
        cursor: crosshair;
        box-shadow: 0 4px 12px rgba(0, 0, 0, .2);
        border-radius: 8px
      }

      .layer-options {
        display: none;
        gap: 15px;
        margin: 10px 0
      }

      .layer-options.active {
        display: flex
      }

      .selected {
        outline: 3px solid #007bff
      }

      .context-menu {
        position: absolute;
        z-index: 100;
        background: #fff;
        border: 1px solid #ccc;
        border-radius: 5px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, .2);
        display: none;
        flex-direction: column;
        padding: 10px
      }

      .context-menu-item {
        padding: 8px 12px;
        cursor: pointer;
        transition: background-color .3s
      }

      .context-menu-item:hover {
        background-color: #f0f2f5
      }

      @media (max-width:600px) {
        .toolbar {
          flex-direction: column
        }
      }

      .submenu {
        display: none;
        position: absolute;
        left: 100%;
        top: 0;
        background: #fff;
        border: 1px solid #ccc;
        box-shadow: 0 4px 10px rgba(0, 0, 0, .2);
        z-index: 101
      }

      .context-menu-item {
        position: relative
      }

      .context-menu-item:hover .submenu {
        display: block
      }

      .submenu-item {
        padding: 8px 12px;
        cursor: pointer;
        transition: background-color .3s
      }

      .submenu-item:hover {
        background-color: #f0f2f5
      }
      
      
      
      
      
      
      
      
      
      
      
      

      
      
      
      
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/4.5.0/fabric.min.js"></script>
  </head>
  <body>
    <div class="toolbar">
      <label for="uploadImage">
        <i class="fas fa-upload"></i>Upload Image </label>
      <input type="file" id="uploadImage" style="display:none" accept="image/*">
      <button id="downloadImage">
        <i class="fas fa-download"></i>Download Image </button>
      <button id="undoButton">
        <i class="fas fa-undo"></i>
      </button>
      <button id="redoButton">
        <i class="fas fa-redo"></i>
      </button>
      <input type="text" id="captionInput" placeholder="Enter caption..." style="margin-left:10px">
      <button>
        <a for="captionCheckbox">Show Caption <input type="checkbox" id="captionCheckbox">
        </a>
        <a for="watermarkCheckbox">Show Watermark <input type="checkbox" id="watermarkCheckbox">
        </a>
      </button>
        <input type="range" id="zoomSlider" min="0.5" max="3" step="0.005" value="1">
    </div>
    <div id="contextMenu" class="context-menu">
      <div class="context-menu-item" id="circularCropButton">Circular Crop</div>
      <div class="context-menu-item" id="layersMenu">Layers <div class="submenu" id="submenu-layers">
          <div class="submenu-item" id="bringToFront">Bring to Front</div>
          <div class="submenu-item" id="sendToBack">Send to Back</div>
          <div class="submenu-item" id="deleteLayerContext">Delete Selected</div>
          <div class="submenu-item" id="duplicateLayer">Duplicate</div>
        </div>
      </div>
      <div class="context-menu-item" id="flipMenu">Flip <div class="submenu" id="submenu-flip">
          <div class="submenu-item" id="flipHorizontal">Flip Horizontal</div>
          <div class="submenu-item" id="flipVertical">Flip Vertical</div>
        </div>
      </div>
      <div class="context-menu-item" id="rotateLayer">Rotate</div>
      <div class="context-menu-item" id="resetTransform">Reset Align</div>
      <div class="context-menu-item" id="pasteImage">Paste</div>
      <div class="context-menu-item" id="setAsBackground">Set as Background</div>
      <div class="context-menu-item" id="detachBackground" style="display:none">Detach Background</div>
      <div class="context-menu-item" id="alignMenu">Align <div class="submenu" id="alignSubmenu">
          <div class="submenu-item" id="alignLeft">Align Left</div>
          <div class="submenu-item" id="alignCenter">Align Center</div>
          <div class="submenu-item" id="alignRight">Align Right</div>
        </div>
      </div>
      <div class="context-menu-item" id="filtersMenu">Filters <div class="submenu" id="submenu">
          <div class="submenu-item" id="grayscaleFilter">Grayscale</div>
          <div class="submenu-item">
            <a for="brightnessFilter">Brightness</a>
            <input type="range" id="brightnessFilter" min="-100" max="100" value="0">
          </div>
          <div class="submenu-item">
            <a for="contrastFilter">Contrast</a>
            <input type="range" id="contrastFilter" min="-100" max="100" value="0">
          </div>
          <div class="submenu-item">
            <a for="saturationFilter">Saturation</a>
            <input type="range" id="saturationFilter" min="-100" max="100" value="0">
          </div>
        </div>
      </div>
    </div>
    <div class="canvas-container" id="canvasContainer">
      <canvas id="imageCanvas" width="800" height="418"></canvas>
    </div>
    <script>
      const canvas = new fabric.Canvas('imageCanvas', {
        preserveObjectStacking: true
      });
      let isCropping = false;
      let cropCircle;
      let history = [];
      let historyIndex = -1;
      // Load image into canvas and center it

      
      document.getElementById('pasteImage').addEventListener('click', function() {
        navigator.clipboard.read().then(items => {
          for (const item of items) {
            if (item.types.includes('image/png')) {
              item.getType('image/png').then(blob => {
                const img = new Image();
                img.src = URL.createObjectURL(blob);
                img.onload = function() {
                  loadImage(img); // Assuming loadImage function is already handling adding image to canvas
                };
              });
            }
          }
        });
        contextMenu.style.display = 'none'; // Hide context menu after action
      });
      document.getElementById('uploadImage').addEventListener('change', function(e) {
        if (e.target.files.length === 0) {
          alert('Please select an image file.');
          return;
        }
        const reader = new FileReader();
        reader.onload = function(event) {
          const img = new Image();
          img.src = event.target.result;
          img.onload = function() {
            loadImage(img);
          };
        };
        reader.readAsDataURL(e.target.files[0]);
      });
      // Handle drag and drop functionality
      const canvasContainer = document.getElementById('canvasContainer');
      canvasContainer.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';
      });
      canvasContainer.addEventListener('drop', function(e) {
        e.preventDefault();
        const files = e.dataTransfer.files;
        if (files.length > 0 && files[0].type.startsWith('image/')) {
          const reader = new FileReader();
          reader.onload = function(event) {
            const img = new Image();
            img.src = event.target.result;
            img.onload = function() {
              loadImage(img);
            };
          };
          reader.readAsDataURL(files[0]);
        } else {
          alert('Please drop a valid image file.');
        }
      });
      // Get context menu element
      const contextMenu = document.getElementById('contextMenu');
      // Handle right-click on canvas
      // Hide context menu on left click or anywhere else
      document.addEventListener('click', function() {
        contextMenu.style.display = 'none';
      });
      // Duplicate layer functionality
      document.getElementById('duplicateLayer').addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          const clonedObject = fabric.util.object.clone(activeObject);
          clonedObject.set({
            left: activeObject.left + 10, // Offset to prevent overlap
            top: activeObject.top + 10,
            selectable: true,
          });
          canvas.add(clonedObject);
          addHistory();
        }
        contextMenu.style.display = 'none'; // Hide context menu
      });
      // Delete layer functionality
      document.getElementById('deleteLayerContext').addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          canvas.remove(activeObject);
          addHistory();
        }
        contextMenu.style.display = 'none'; // Hide context menu
      });
      // Bring to front functionality
      document.getElementById('bringToFront').addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          canvas.bringToFront(activeObject);
          addHistory();
        }
        contextMenu.style.display = 'none'; // Hide context menu
      });
      // Send to back functionality
      document.getElementById('sendToBack').addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          canvas.sendToBack(activeObject);
          addHistory();
        }
        contextMenu.style.display = 'none'; // Hide context menu
      });
      // Handle double click to crop
      canvas.on('mouse:dblclick', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject && activeObject.type === 'image') {
          enterCropMode(activeObject);
        }
      });
      // Enter Crop Mode
      function enterCropMode(image) {
        if (isCropping) return; // Already cropping
        isCropping = true;
        // Create a cropping rectangle over the image
        cropRect = new fabric.Rect({
          left: image.left,
          top: image.top,
          width: image.width * image.scaleX,
          height: image.height * image.scaleY,
          fill: 'rgba(0,0,0,0.3)',
          hasBorders: true,
          hasControls: true,
          selectable: true,
        });
        canvas.add(cropRect);
        canvas.setActiveObject(cropRect);
        canvas.renderAll();
        // Add crop and cancel buttons
        const cropButton = document.createElement('button');
        cropButton.innerText = 'Crop';
        cropButton.style.position = 'absolute';
        cropButton.style.top = '10px';
        cropButton.style.right = '10px';
        document.body.appendChild(cropButton);
        cropButton.addEventListener('click', function() {
          cropImage(image);
          document.body.removeChild(cropButton); // Remove crop button after action
        });
      }
      // Crop the image based on cropping rectangle
      function cropImage(image) {
        if (!cropRect) return;
        const croppedLeft = cropRect.left - image.left;
        const croppedTop = cropRect.top - image.top;
        const croppedWidth = cropRect.width * cropRect.scaleX;
        const croppedHeight = cropRect.height * cropRect.scaleY;
        const croppedCanvas = document.createElement('canvas');
        croppedCanvas.width = croppedWidth;
        croppedCanvas.height = croppedHeight;
        const croppedCtx = croppedCanvas.getContext('2d');
        croppedCtx.drawImage(image._element, croppedLeft / image.scaleX, croppedTop / image.scaleY, croppedWidth / image.scaleX, croppedHeight / image.scaleY, 0, 0, croppedWidth, croppedHeight);
        const croppedImg = new Image();
        croppedImg.src = croppedCanvas.toDataURL();
        croppedImg.onload = function() {
          const newImage = new fabric.Image(croppedImg);
          newImage.set({
            left: image.left,
            top: image.top,
            scaleX: image.scaleX,
            scaleY: image.scaleY,
            hasControls: true,
            hasBorders: true,
          });
          canvas.remove(image); // Remove original image
          canvas.add(newImage); // Add cropped image
          canvas.setActiveObject(newImage);
          canvas.renderAll();
          addHistory(); // Add to history after cropping
        };
        canvas.remove(cropRect); // Remove cropping rectangle after cropping
        isCropping = false;
        cropRect = null;
      }
      // Circular Crop Button
      document.getElementById('circularCropButton').addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject && activeObject.type === 'image') {
          enterCircularCropMode(activeObject);
        }
      });
      // Enter Circular Crop Mode
      function enterCircularCropMode(image) {
        if (isCropping) return; // Already cropping
        isCropping = true;
        // Create a cropping circle over the image
        const centerX = image.left + (image.width * image.scaleX) / 2;
        const centerY = image.top + (image.height * image.scaleY) / 2;
        const radius = Math.min(image.width * image.scaleX, image.height * image.scaleY) / 2;
        cropCircle = new fabric.Circle({
          left: centerX - radius,
          top: centerY - radius,
          radius: radius,
          fill: 'rgba(0,0,0,0.3)',
          hasBorders: true,
          hasControls: true,
          selectable: true,
        });
        canvas.add(cropCircle);
        canvas.setActiveObject(cropCircle);
        canvas.renderAll();
        // Add crop and cancel buttons
        const cropButton = document.createElement('button');
        cropButton.innerText = 'Crop';
        cropButton.style.position = 'absolute';
        cropButton.style.top = '10px';
        cropButton.style.right = '10px';
        document.body.appendChild(cropButton);
        cropButton.addEventListener('click', function() {
          cropCircleImage(image);
          document.body.removeChild(cropButton); // Remove crop button after action
        });
      }
      // Crop the image based on cropping circle
      function cropCircleImage(image) {
        if (!cropCircle) return;
        const cropRadius = cropCircle.radius * cropCircle.scaleX; // Consider circle scaling
        const circleCenterX = cropCircle.left + cropRadius; // X center of the crop circle
        const circleCenterY = cropCircle.top + cropRadius; // Y center of the crop circle
        const croppedCanvas = document.createElement('canvas');
        const croppedCtx = croppedCanvas.getContext('2d');
        // Set the canvas size to match the diameter of the crop circle
        const diameter = cropRadius * 2;
        croppedCanvas.width = diameter;
        croppedCanvas.height = diameter;
        // Draw a circular clipping path
        croppedCtx.beginPath();
        croppedCtx.arc(cropRadius, cropRadius, cropRadius, 0, Math.PI * 2, false);
        croppedCtx.clip();
        // Calculate image offset within the crop circle
        const imageLeftOffset = (circleCenterX - cropRadius - image.left) / image.scaleX;
        const imageTopOffset = (circleCenterY - cropRadius - image.top) / image.scaleY;
        // Draw the image into the clipped circular area
        croppedCtx.drawImage(image._element, imageLeftOffset, // Source X
          imageTopOffset, // Source Y
          diameter / image.scaleX, // Source Width
          diameter / image.scaleY, // Source Height
          0, // Destination X
          0, // Destination Y
          diameter, // Destination Width
          diameter // Destination Height
        );
        // Create a new fabric image with the cropped circular content
        const croppedImg = new Image();
        croppedImg.src = croppedCanvas.toDataURL();
        croppedImg.onload = function() {
          const newImage = new fabric.Image(croppedImg, {
            left: image.left + (circleCenterX - cropRadius - image.left), // Correct X position
            top: image.top + (circleCenterY - cropRadius - image.top), // Correct Y position
            hasControls: true,
            hasBorders: true,
            selectable: true
          });
          // Replace the original image with the cropped circular image
          canvas.remove(image);
          canvas.add(newImage);
          canvas.setActiveObject(newImage);
          canvas.renderAll();
          addHistory(); // Add to history after cropping
        };
        // Remove the crop circle and reset cropping state
        canvas.remove(cropCircle);
        cropCircle = null;
        isCropping = false;
      }
      // Undo Functionality
      document.getElementById('undoButton').addEventListener('click', function() {
        if (historyIndex > 0) {
          historyIndex--;
          restoreCanvasState(history[historyIndex]);
        }
      });
      // Redo Functionality
      document.getElementById('redoButton').addEventListener('click', function() {
        if (historyIndex < history.length - 1) {
          historyIndex++;
          restoreCanvasState(history[historyIndex]);
        }
      });
      // Helper function to restore canvas state
      function restoreCanvasState(state) {
        canvas.clear();
        state.forEach(function(item) {
          // Re-create the fabric objects from the state
          const obj = fabric.util.enlivenObjects([item], function(enlivedObjects) {
            enlivedObjects.forEach(function(newObj) {
              canvas.add(newObj);
            });
            canvas.renderAll();
          });
        });
      }
      // Add to history function
      function addHistory() {
        if (historyIndex < history.length - 1) {
          // Limit history size
          history = history.slice(0, historyIndex + 1);
        }
        // Clone the current canvas state
        const currentState = canvas.getObjects().map(function(obj) {
          return fabric.util.object.clone(obj); // Clone objects for history
        });
        history.push(currentState);
        historyIndex++;
        // Limit history length (for example, to the last 50 states)
        if (history.length > 50) {
          history.shift(); // Remove the oldest state
          historyIndex--; // Adjust the index accordingly
        }
      }
      // Flip Horizontally
      document.getElementById('flipHorizontal').addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          activeObject.scaleX = -activeObject.scaleX; // Flip the object
          canvas.renderAll();
          addHistory(); // Add to history after flipping
        }
        contextMenu.style.display = 'none'; // Hide context menu
      });
      // Flip Vertically
      document.getElementById('flipVertical').addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          activeObject.scaleY = -activeObject.scaleY; // Flip the object
          canvas.renderAll();
          addHistory(); // Add to history after flipping
        }
        contextMenu.style.display = 'none'; // Hide context menu
      });
      // Rotate Layer
      document.getElementById('rotateLayer').addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          activeObject.angle = (activeObject.angle + 90) % 360; // Rotate the object by 90 degrees
          canvas.renderAll();
          addHistory(); // Add to history after rotating
        }
        contextMenu.style.display = 'none'; // Hide context menu
      });
      document.getElementById('resetTransform').addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          activeObject.set({
            scaleX: 1,
            scaleY: 1,
            angle: 0,
            left: 0,
            top: 0,
          });
          addHistory();
          canvas.renderAll();
        }
      });
      document.getElementById('alignLeft').addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          activeObject.set('left', 0);
          canvas.renderAll();
          addHistory();
        }
      });
      document.getElementById('alignCenter').addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          activeObject.set('left', (canvas.width - activeObject.width) / 2);
          canvas.renderAll();
          addHistory();
        }
      });
      document.getElementById('alignRight').addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          activeObject.set('left', canvas.width - activeObject.width);
          canvas.renderAll();
          addHistory();
        }
      });
      
      
      
      
      
      // Function to load an image and scale it properly onto the canvas
function loadImage(img) {
  const imgInstance = new fabric.Image(img);
  
  // Calculate scaling factor based on canvas dimensions
  const canvasAspect = canvas.width / canvas.height;
  const imgAspect = img.width / img.height;

  let scaleFactor;
  if (canvasAspect > imgAspect) {
    scaleFactor = canvas.height / img.height; // Fit to height
  } else {
    scaleFactor = canvas.width / img.width; // Fit to width
  }

  imgInstance.set({
    left: (canvas.width - img.width * scaleFactor) / 2, // Center horizontally
    top: (canvas.height - img.height * scaleFactor) / 2, // Center vertically
    scaleX: scaleFactor,
    scaleY: scaleFactor,
    hasControls: true,
    hasBorders: true,
    selectable: true,
  });

  canvas.add(imgInstance).setActiveObject(imgInstance);
  canvas.renderAll();
  addHistory(); // Add to history after adding an image
  updateLayerOptions(true);
}










    // Function to create a Web Worker for size calculation
const createWorker = () => {
  const blob = new Blob([`
    onmessage = function(e) {
      const dataUrl = e.data.dataUrl;
      const byteString = atob(dataUrl.split(',')[1]);
      postMessage({ size: byteString.length });
    }
  `], { type: 'application/javascript' });
  return new Worker(URL.createObjectURL(blob));
};

// Enhanced adaptive binary search for best quality within size limit
const adaptiveBinarySearch = async (canvas, maxFileSize, minQuality = 0.05, maxQuality = 1.0) => {
  let lower = minQuality;
  let upper = maxQuality;
  let resultQuality = minQuality;
  let step = 0.00001; // Ultra-fine steps for precision

  while (upper - lower > step) {
    const midQuality = (lower + upper) / 2;
    const dataUrl = canvas.toDataURL("image/webp", midQuality);

    const size = await new Promise((resolve, reject) => {
      const worker = createWorker();
      worker.onmessage = (e) => {
        resolve(e.data.size);
        worker.terminate();
      };
      worker.onerror = (error) => {
        console.error("Worker error during compression:", error);
        worker.terminate();
        reject(error);
      };
      worker.postMessage({ dataUrl });
    }).catch(() => 0);

    if (size <= maxFileSize) {
      resultQuality = midQuality; // Save the optimal quality
      lower = midQuality;
    } else {
      upper = midQuality;
    }
  }
  return resultQuality;
};

// Function to compress image to highest quality under size limit
const compressImage = async (canvas, maxFileSize = 50 * 1024) => {
  const optimalQuality = await adaptiveBinarySearch(canvas, maxFileSize);
  return canvas.toDataURL("image/webp", optimalQuality);
};

// Event listener for downloading the image
document.getElementById('downloadImage').addEventListener('click', async function() {
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = 1200;
  tempCanvas.height = 628;
  const ctx = tempCanvas.getContext('2d');

  const imageData = canvas.toDataURL("image/png", 1.0);
  const img = new Image();
  img.onload = async function() {
    // Draw image with high-quality settings
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = "high";
    ctx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);

    // Add caption if checked
    const caption = document.getElementById('captionInput').value;
    const showCaption = document.getElementById('captionCheckbox').checked;
    if (showCaption && caption) addCaption(ctx, tempCanvas, caption);

    // Add watermark if checked
    const showWatermark = document.getElementById('watermarkCheckbox').checked;
    if (showWatermark) addWatermark(ctx, tempCanvas);

    // Compress and download the image
    const downloadDataUrl = await compressImage(tempCanvas, 50 * 1024);
    const downloadLink = document.createElement('a');
    downloadLink.href = downloadDataUrl;
    downloadLink.download = `VvipTimes_${caption.replace(/\s+/g, '_')}.webp`;
    document.body.appendChild(downloadLink);
    downloadLink.click();
    document.body.removeChild(downloadLink);
  };
  img.src = imageData;
});

// Caption addition
function addCaption(ctx, canvas, caption) {
  ctx.font = "500 22px Arial";
  ctx.fillStyle = "black";
  ctx.globalAlpha = 0.7;
  const textMetrics = ctx.measureText(caption);
  const textHeight = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent;
  
  // Create a rounded rectangle background for the caption
  ctx.beginPath();
  ctx.roundRect(0, canvas.height - (textHeight + 10), canvas.width, textHeight + 10, 15);
  ctx.fill();
  
  // Draw the caption text
  ctx.globalAlpha = 1; // Reset alpha for text
  ctx.fillStyle = "white";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(caption, canvas.width / 2, canvas.height - (textHeight / 2 + 5));
}

// Watermark addition
function addWatermark(ctx, canvas) {
  const padding = 5;
  ctx.font = "700 24px Arial";
  ctx.fillStyle = "#010642";
  ctx.globalAlpha = 0.77;
  
  // Create a rounded rectangle for the watermark background
  ctx.beginPath();
  ctx.roundRect(canvas.width - 150 - padding, padding, 150, 36, 50);
  ctx.fill();
  
  // Draw the watermark text
  ctx.globalAlpha = 1; // Reset alpha for text
  ctx.fillStyle = "white";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("VvipTimes", canvas.width - 75 - padding, padding + 18);
}








      
      

      // Get submenu and filter item
      // Get references to the sliders
      const brightnessSlider = document.getElementById('brightnessFilter');
      const contrastSlider = document.getElementById('contrastFilter');
      const saturationSlider = document.getElementById('saturationFilter');
      const grayscaleButton = document.getElementById('grayscaleFilter');
      // Function to apply the filters
      function applyFilters() {
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          activeObject.filters = [];
          // Apply Brightness Filter
          const brightnessValue = brightnessSlider.value / 100; // Normalize value between -1 and 1
          const brightnessFilter = new fabric.Image.filters.Brightness({
            brightness: brightnessValue
          });
          activeObject.filters.push(brightnessFilter);
          // Apply Contrast Filter
          const contrastValue = contrastSlider.value / 100; // Normalize value between -1 and 1
          const contrastFilter = new fabric.Image.filters.Contrast({
            contrast: contrastValue
          });
          activeObject.filters.push(contrastFilter);
          // Apply Saturation Filter
          const saturationValue = saturationSlider.value / 100; // Normalize value between -1 and 1
          const saturationFilter = new fabric.Image.filters.Saturation({
            saturation: saturationValue
          });
          activeObject.filters.push(saturationFilter);
          // Re-apply all filters and render the canvas
          activeObject.applyFilters();
          canvas.renderAll();
        }
      }
      // Add event listeners to the sliders to apply filters dynamically
      brightnessSlider.addEventListener('input', applyFilters);
      contrastSlider.addEventListener('input', applyFilters);
      saturationSlider.addEventListener('input', applyFilters);
      // Grayscale Filter Button
      grayscaleButton.addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          activeObject.filters = [];
          const grayscaleFilter = new fabric.Image.filters.Grayscale();
          activeObject.filters.push(grayscaleFilter);
          // Apply Grayscale filter and render the canvas
          activeObject.applyFilters();
          canvas.renderAll();
          addHistory();
        }
      });
      // Listen for keydown events on the entire document
      document.addEventListener('keydown', function(event) {
        // Check if the key pressed is either Backspace (keyCode 8) or Delete (keyCode 46)
        if (event.key === 'Backspace' || event.key === 'Delete') {
          // Prevent the default browser behavior (like navigating back in case of Backspace)
          event.preventDefault();
          // Get the currently active object on the canvas
          const activeObject = canvas.getActiveObject();
          // If there is an active object, remove it from the canvas
          if (activeObject) {
            canvas.remove(activeObject);
            addHistory();
            canvas.renderAll(); // Re-render the canvas
          }
        }
      });
      let backgroundImage = null;
      document.getElementById('setAsBackground').addEventListener('click', function() {
        const activeObject = canvas.getActiveObject();
        if (activeObject && activeObject.type === 'image') {
          const img = new Image();
          img.src = activeObject.toDataURL(); // Get the image data URL
          img.onload = function() {
            const canvasWidth = 800; // dynamic canvas width
            const canvasHeight = 418; // dynamic canvas height
            const outputWidth = 1200; // output image width
            const outputHeight = 628; // output image height
            const imgRatio = img.width / img.height; // Image aspect ratio
            const canvasRatio = canvasWidth / canvasHeight; // Canvas aspect ratio
            const outputRatio = outputWidth / outputHeight; // Output image aspect ratio
            let drawWidth, drawHeight;
            // Adjust dimensions based on aspect ratios
            if (imgRatio > outputRatio) {
              // Image is wider compared to the output canvas
              drawWidth = outputWidth;
              drawHeight = outputWidth / imgRatio;
            } else {
              // Image is taller compared to the output canvas
              drawHeight = outputHeight;
              drawWidth = outputHeight * imgRatio;
            }
            // Scale the canvas to match output image size
            canvas.setDimensions({
              width: canvasWidth,
              height: canvasHeight
            });
            // Set the image on the canvas with accurate scaling and center alignment
            canvas.setBackgroundImage(img.src, canvas.renderAll.bind(canvas), {
              originX: 'left', // Align from the left
              originY: 'top', // Align from the top
              left: (canvasWidth - drawWidth) / 2, // Center horizontally
              top: (canvasHeight - drawHeight) / 2, // Center vertically
              scaleX: drawWidth / img.width, // Scale to fit width
              scaleY: drawHeight / img.height // Scale to fit height
            });
            // Store the original image as background
            backgroundImage = activeObject;
            // Remove the image object from the canvas after setting it as background
            canvas.remove(activeObject);
            // Hide the "Set as Background" and show "Detach Background"
            document.getElementById('setAsBackground').style.display = 'none';
            document.getElementById('detachBackground').style.display = 'block';
            addHistory(); // Add this action to history for undo functionality
          };
        }
        contextMenu.style.display = 'none'; // Hide the context menu after action
      });
      document.getElementById('detachBackground').addEventListener('click', function() {
  if (backgroundImage) {
    // Remove the background image from the canvas
    canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas));
    
    // Create a new Image instance from the original image's data URL
    const originalImg = new Image();
    originalImg.src = backgroundImage.toDataURL(); // Get the original image data URL

    originalImg.onload = function() {
      // Create an image instance for fabric.js
      const imgInstance = new fabric.Image(originalImg, {
        left: (canvas.width - originalImg.width) / 2, // Center the image horizontally
        top: (canvas.height - originalImg.height) / 2, // Center the image vertically
        selectable: true,
        hasControls: true, // Make sure the image is selectable and has controls
        hasBorders: true
      });
      
      // Add the image back to the canvas
      canvas.add(imgInstance);
      canvas.setActiveObject(imgInstance); // Set the newly added image as active
      canvas.renderAll(); // Refresh the canvas

      // Clear the reference to the background image
      backgroundImage = null;

      // Hide "Detach Background" and show "Set as Background"
      document.getElementById('setAsBackground').style.display = 'block';
      document.getElementById('detachBackground').style.display = 'none';

      // Add this action to history for undo functionality
      addHistory();
    };
  }
  contextMenu.style.display = 'none'; // Hide the context menu after action
});


      canvasContainer.addEventListener('contextmenu', function(e) {
        e.preventDefault(); // Prevent default context menu
        const activeObject = canvas.getActiveObject();
        const canvasHasObjects = canvas.getObjects().length > 0; // Check if canvas has any objects
        const hasBackgroundImage = !!canvas.backgroundImage; // Check if a background image is set
        // Clear previous context menu state
        document.getElementById('pasteImage').style.display = 'none';
        document.getElementById('setAsBackground').style.display = 'none';
        document.getElementById('detachBackground').style.display = 'none';
        document.getElementById('layersMenu').style.display = 'none';
        document.getElementById('flipMenu').style.display = 'none';
        document.getElementById('rotateLayer').style.display = 'none';
        document.getElementById('resetTransform').style.display = 'none';
        document.getElementById('alignMenu').style.display = 'none';
        document.getElementById('filtersMenu').style.display = 'none';
        document.getElementById('circularCropButton').style.display = 'none';
        // If the canvas has no objects, only show the "Paste" option
        if (!canvasHasObjects) {
          document.getElementById('pasteImage').style.display = 'block';
        }
        // If an image is selected, show the full context menu
        if (activeObject && activeObject.type === 'image') {
          document.getElementById('pasteImage').style.display = 'block'; // Always show paste
          document.getElementById('setAsBackground').style.display = 'block'; // Show "Set as Background" for images
          document.getElementById('layersMenu').style.display = 'block';
          document.getElementById('flipMenu').style.display = 'block';
          document.getElementById('rotateLayer').style.display = 'block';
          document.getElementById('resetTransform').style.display = 'block';
          document.getElementById('alignMenu').style.display = 'block';
          document.getElementById('filtersMenu').style.display = 'block';
          document.getElementById('circularCropButton').style.display = 'block';
        }
        // Show "Detach Background" option only if a background image has been set
        if (hasBackgroundImage) {
          document.getElementById('detachBackground').style.display = 'block';
        }
        // Position the context menu at the point of the right-click
        contextMenu.style.left = `${e.clientX}px`;
        contextMenu.style.top = `${e.clientY}px`;
        contextMenu.style.display = 'block'; // Show the context menu
      });
      
      
      
      
      
      
      
      
      
      
    
    
    
    
    
    
    
    
    
    // Configuration Constants
const CORNER_COLOR = 'rgba(75, 0, 130, 0.9)';
const CORNER_STROKE_COLOR = 'indigo';
const CORNER_STYLE = 'circle';
const CORNER_STROKE_WIDTH = 2;

const CORNER_SIZE = 20; // Size of corner handles
const SHADOW_COLOR = 'rgba(75, 0, 130, 0.9)';
const SHADOW_BLUR = 30;
const SHADOW_OFFSET_X = 5;
const SHADOW_OFFSET_Y = 5;

const DASHED_BORDER = [6, 8]; // Dashed border effect

// Extend Fabric.js to customize corner behavior
fabric.Object.prototype.cornerColor = CORNER_COLOR;
fabric.Object.prototype.cornerStrokeColor = CORNER_STROKE_COLOR;
fabric.Object.prototype.cornerStyle = CORNER_STYLE;
fabric.Object.prototype.cornerStrokeWidth = CORNER_STROKE_WIDTH;

// Customize the corner size and position
fabric.Object.prototype.corners = {
    tl: { x: -12, y: -12 },  // Top Left
    tr: { x: 12, y: -12 },   // Top Right
    bl: { x: -12, y: 12 },   // Bottom Left
    br: { x: 12, y: 12 }     // Bottom Right
};

// Function to customize corner rendering
fabric.Object.prototype._renderCorners = function(ctx) {
    ctx.save();
    ctx.fillStyle = this.cornerColor;
    ctx.strokeStyle = this.cornerStrokeColor;
    ctx.lineWidth = this.cornerStrokeWidth;

    // Draw circular corners
    Object.entries(this.corners).forEach(([key, { x, y }]) => {
        ctx.beginPath();
        ctx.arc(this.left + x + this.width / 2, this.top + y + this.height / 2, CORNER_SIZE, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.closePath();
    });

    ctx.restore();
};

// Function to set common styles for images
function setImageStyles(obj, styles) {
    if (!obj || !obj.type === 'image') return; // Validate object

    obj.set({
        borderColor: styles.borderColor || '',
        borderDashArray: styles.borderDashArray || null,
        cornerColor: styles.cornerColor || '',
        cornerStrokeColor: styles.cornerStrokeColor || '',
        shadow: styles.shadow || null,
        opacity: styles.opacity !== undefined ? styles.opacity : 1,
        selectable: true,
        evented: true,
        padding: 3,
    });
}

// Enhance visual feedback on selection
function enhanceSelectedImages() {
    const activeObjects = canvas.getActiveObjects();

    activeObjects.forEach((obj) => {
        if (obj.type === 'image') {
            setImageStyles(obj, {
                borderColor: 'rgba(75, 0, 130, 0.9)', // Selection border color
                borderDashArray: DASHED_BORDER, // Dashed border effect
                cornerColor: 'rgba(75, 0, 130, 1)', // Brighter corner color
                shadow: new fabric.Shadow({
                    color: SHADOW_COLOR, 
                    blur: SHADOW_BLUR,
                    offsetX: SHADOW_OFFSET_X,
                    offsetY: SHADOW_OFFSET_Y
                })
            });
        }
    });

    canvas.renderAll(); // Refresh the canvas to apply styles
}

// Reset styles when selection is cleared
canvas.on('selection:cleared', function() {
    canvas.getObjects().forEach((obj) => {
        if (obj.type === 'image') {
            setImageStyles(obj, {
                borderColor: '',
                borderDashArray: null, // Reset dashed border
                cornerColor: '',
                cornerStrokeColor: '',
                shadow: null,
                opacity: 1, // Reset opacity
            });
        }
    });

    canvas.renderAll(); // Refresh the canvas
});

// Hover effect for images
canvas.on('mouse:over', function(event) {
    if (event.target && event.target.type === 'image') {
        event.target.set('shadow', new fabric.Shadow({
            color: SHADOW_COLOR, // Shadow color on hover
            blur: 25,
            offsetX: 0,
            offsetY: 0,
        }));
        canvas.renderAll(); // Refresh canvas
    }
});

// Remove shadow on mouse out
canvas.on('mouse:out', function(event) {
    if (event.target && event.target.type === 'image') {
        event.target.set('shadow', null); // Remove shadow on mouse out
        canvas.renderAll(); // Refresh canvas
    }
});

// Apply enhancements on selection
canvas.on('selection:created', enhanceSelectedImages);
canvas.on('selection:updated', enhanceSelectedImages);





    // Function to zoom the canvas container
function zoomCanvas(scale) {
    const canvasContainer = document.getElementById('canvasContainer'); // Adjust this if your container ID is different
    canvasContainer.style.transform = `scale(${scale})`;
    canvasContainer.style.transformOrigin = 'top left'; // Ensure scaling happens from the top left corner
}

// Event listener for the zoom slider
document.getElementById('zoomSlider').addEventListener('input', function(event) {
    const scaleValue = event.target.value; // Get the current value of the slider
    zoomCanvas(scaleValue); // Call the zoom function with the slider value
});

    
    
    
      
      
      
    </script>
  </body>
</html>
