<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <style>
      body {
        font-family: 'Segoe UI', sans-serif;
        background: #f0fff0;
        margin: 0;
        padding: 0;
        color: #333
      }

      .container {
        max-width: 1160px;
        margin: auto;
        padding: 30px;
        text-align: center
      }

      h1 {
        font-size: 3rem;
        margin-bottom: 20px;
        color: navy
      }

      form {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px
      }

      input[type=text] {
        border: 2px dashed navy;
        border-radius: 8px;
        padding: 12px;
        width: 100%;
        max-width: auto;
        font-size: 1.4rem;
        text-align: center
      }

      button {
        background: indigo;
        color: #fff;
        border: none;
        border-radius: 50px;
        padding: 12px;
        font-size: 1.4rem;
        cursor: pointer;
        transition: background .3s;
        width: 200px;
        max-width: 400px
      }

      button:hover {
        background: #000
      }

      .drag-drop-area {
        border: 2px dashed navy;
        border-radius: 12px;
        padding: 50px;
        min-height: 30vh;
        background: #fff;
        cursor: pointer;
        position: relative;
        margin: 20px 0;
        transition: border-color .3s, background .3s
      }

      .drag-drop-area.dragover {
        border-color: #004d40;
        background: #b2dfdb
      }

      .drag-drop-area::after {
        content: 'Drag & Drop Images Here';
        color: navy;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 2rem
      }

      .image-preview-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 15px
      }

      .image-wrapper {
        position: relative;
        width: 100%;
        height: 0;
        padding-top: 52%
      }

      .image-wrapper img {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover
      }

      .remove-image-button {
        position: absolute;
        top: 3px;
        right: 3px;
        background: rgba(0, 0, 0, .7);
        color: #fff;
        border: none;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 1.6rem;
        z-index: 1
      }

      .remove-image-button:hover {
        background: rgba(0, 0, 0, .9)
      }

      .caption {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(0, 0, 0, .7);
        color: #fff;
        padding: 5px 10px;
        border-radius: 5px;
        font-size: 14px;
        text-align: center;
        width: calc(100% - 20px)
      }

      .watermark {
        position: absolute;
        bottom: 10px;
        right: 10px;
        background: rgba(0, 0, 0, .5);
        color: #fff;
        padding: 5px 10px;
        border-radius: 5px;
        font-size: 14px;
        text-align: center;
        z-index: 1
      }

      .loading-spinner {
        border: 16px solid #f3f3f3;
        border-top: 16px solid #00796b;
        border-radius: 50%;
        width: 80px;
        height: 80px;
        animation: spin 1s linear infinite;
        margin: 20px auto
      }

      .notification {
        background: #00796b;
        color: #fff;
        padding: 15px;
        border-radius: 8px;
        margin: 20px auto;
        width: 90%;
        max-width: 400px
      }

      @keyframes spin {
        0% {
          transform: rotate(0)
        }

        100% {
          transform: rotate(360deg)
        }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.26.0/babel.min.js"></script>
    <script type="text/babel">
        const { useState, useRef, useCallback } = React;

const App = () => {
  const [imageUrls, setImageUrls] = useState([]);
  const [caption, setCaption] = useState('');
  const [loading, setLoading] = useState(false);
  const [notification, setNotification] = useState('');
  const dragDropRef = useRef(null);

  const handleFileUpload = useCallback((files) => {
    const newImageUrls = [];
    Array.from(files).forEach(file => {
      if (file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = (e) => {
          newImageUrls.push(e.target.result);
          setImageUrls(prev => [...prev, ...newImageUrls]);
        };
        reader.readAsDataURL(file);
      } else {
        showNotification('Only image files are supported.', 'error');
      }
    });
  }, []);

  const handleDrop = useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();
    handleFileUpload(e.dataTransfer.files);
    dragDropRef.current.classList.remove('dragover');
  }, [handleFileUpload]);

  const handleDragOver = useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();
    dragDropRef.current.classList.add('dragover');
  }, []);

  const handleDragLeave = useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();
    dragDropRef.current.classList.remove('dragover');
  }, []);

  const showNotification = (message, type = 'success') => {
    setNotification({ message, type });
    setTimeout(() => setNotification(''), 5000);
  };

  const compressImage = async (canvas) => {
    const maxFileSize = 50 * 1024; // 50 KB
    let quality = 1.0;
    let dataUrl = '';
    let compressedBlob = null;

    while (quality > 0) {
      dataUrl = canvas.toDataURL('image/webp', quality);
      compressedBlob = await fetch(dataUrl).then(res => res.blob());
      if (compressedBlob.size <= maxFileSize) break;
      quality -= 0.01; // Finer quality decrement
    }

    return dataUrl;
  };

  const downloadImage = useCallback(async () => {
    if (imageUrls.length === 0) {
        showNotification('No images to process.', 'error');
        return;
    }

    setLoading(true);
    try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const imgCount = imageUrls.length;

        canvas.width = 1200;
        canvas.height = 628;

        const imageElements = imageUrls.map((src) => {
            const img = new Image();
            img.src = src;
            return new Promise((resolve) => {
                img.onload = () => resolve(img);
            });
        });

        const images = await Promise.all(imageElements);

        const layoutMap = [
          (ctx, images) => {
            ctx.drawImage(images[0], 0, 0, canvas.width, canvas.height);
          },
          (ctx, images) => {
            ctx.drawImage(images[0], 0, 0, canvas.width / 2, canvas.height);
            ctx.drawImage(images[1], canvas.width / 2, 0, canvas.width / 2, canvas.height);
          },
          (ctx, images) => {
            ctx.drawImage(images[0], 0, 0, canvas.width / 2, canvas.height / 2);
            ctx.drawImage(images[1], canvas.width / 2, 0, canvas.width / 2, canvas.height / 2);
            ctx.drawImage(images[2], 0, canvas.height / 2, canvas.width, canvas.height / 2);
          },
          (ctx, images) => {
            ctx.drawImage(images[0], 0, 0, canvas.width / 2, canvas.height / 2);
            ctx.drawImage(images[1], canvas.width / 2, 0, canvas.width / 2, canvas.height / 2);
            ctx.drawImage(images[2], 0, canvas.height / 2, canvas.width / 2, canvas.height / 2);
            ctx.drawImage(images[3], canvas.width / 2, canvas.height / 2, canvas.width / 2, canvas.height / 2);
          }
          // Add more layouts if needed
        ];

        if (imgCount <= 10) {
          layoutMap[imgCount - 1](ctx, images);
        } else {
          showNotification('Too many images.', 'error');
          return;
        }

        // Add watermark
        ctx.font = '700 24px Arial';
        ctx.fillStyle = '#010642';
        ctx.globalAlpha = 0.77;
        ctx.beginPath();
        ctx.roundRect(canvas.width - 158, 10, 148, 36, 50);
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Vvip Times', canvas.width - 79, 28);

        // Add caption
        if (caption) {
          ctx.font = '500 20px Arial';
          ctx.fillStyle = 'black';
          ctx.globalAlpha = 0.5;
          const textMetrics = ctx.measureText(caption);
          const captionHeight = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent + 10;
          ctx.beginPath();
          ctx.roundRect(0, canvas.height - captionHeight - 10, canvas.width, captionHeight, 15);
          ctx.fill();
          ctx.globalAlpha = 1;
          ctx.fillStyle = 'white';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(caption, canvas.width / 2, canvas.height - captionHeight / 2);
        }

        const dataUrl = await compressImage(canvas);
        const link = document.createElement('a');
        link.href = dataUrl;
        link.download = 'VvipTimes.webp';
        link.click();
    } catch (error) {
        showNotification('Error processing image.', 'error');
    } finally {
        setLoading(false);
    }
  }, [imageUrls, caption]);

  const removeImage = useCallback((index) => {
    setImageUrls(prev => prev.filter((_, i) => i !== index));
  }, []);

  return (
    <div className="container">
      <h1>Vvip Times Image Creator Pro++</h1>
      <div className="drag-drop-area"
        ref={dragDropRef}
        onDrop={handleDrop}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
      ></div>
      <form>
        <input
          type="text"
          placeholder="Enter caption"
          value={caption}
          onChange={(e) => setCaption(e.target.value)}
        />
        <button type="button" onClick={downloadImage}>Download Image</button>
      </form><br />
      {loading && <div className="loading-spinner"></div>}
      {notification && <div className={`notification ${notification.type}`}>{notification.message}</div>}
      <div className="image-preview-container">
        {imageUrls.map((url, index) => (
          <div key={index} className="image-wrapper">
            <img src={url} alt={`Preview ${index + 1}`} />
            <button
              className="remove-image-button"
              onClick={() => removeImage(index)}
            >×</button>
            {caption && <div className="caption">{caption}</div>}
          </div>
        ))}
      </div>
    </div>
  );
};

ReactDOM.render(<App />, document.getElementById('root'));


		</script>
  </body>
</html>
