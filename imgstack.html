<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Vvip Times Multi Image Creator Pro ++ (Enhanced)</title><style>body{font-family:"Segoe UI",sans-serif;background:#f0fff0;margin:0;padding:0;color:#333}.container{max-width:1200px;margin:auto;padding:30px;text-align:center}h1{font-size:3rem;margin-bottom:20px;color:navy}form{display:flex;flex-direction:column;align-items:center;gap:15px}input[type=text]{border:2px dashed navy;border-radius:8px;padding:12px;width:100%;font-size:1.4rem;text-align:center}button{background:#4a0026f2;color:#fff;border:10px solid #ff69b4;border-radius:50px;padding:9px;font-size:1.5rem;cursor:pointer;transition:background .3s;width:250px;max-width:400px}button:hover{background:#08005df5;border:10px solid #0071f9f0;color:#fff}.drag-drop-area{border:2px dashed navy;border-radius:12px;padding:60px 250px;min-height:30vh;min-width:30vw;background:#fff;cursor:pointer;position:relative;margin:20px 0;transition:border-color .3s,background .3s}.drag-drop-area.dragover{border-color:#004d40;background:#b2dfdb}.drag-drop-area input[type=file]{display:none}.drag-drop-area::after{content:"Drag & Drop or Click to Upload Images";color:navy;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:2rem;font-weight:600}.image-preview-container{display:grid;grid-template-columns:repeat(auto-fit,minmax(350px,1fr));gap:10px;background:#ff69b4;padding:10px;border-radius:12px}.image-wrapper{position:relative;width:100%;height:0;padding-top:52%}.image-wrapper img{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover}.remove-image-button{position:absolute;top:3px;right:3px;background:rgba(0,0,0,.7);color:#fff;border:none;border-radius:50%;width:30px;height:30px;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:1.6rem;z-index:1}.remove-image-button:hover{background:rgba(0,0,0,.9);border:3px solid #ff69b4}.loading-spinner{border:60px solid #000000da;border-top:60px solid #09004f;border-radius:50%;width:300px;height:300px;animation:spin 1s linear infinite;margin:20px auto}.notification{background:#00796b;color:#fff;padding:15px;border-radius:8px;margin:20px auto;width:90%;max-width:400px}@keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}</style></head><body><div id="root"></div><script src="https://unpkg.com/react@18/umd/react.development.js"></script><script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script><script src="https://unpkg.com/babel-standalone@6.26.0/babel.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js"></script><script src="https://cdn.jsdelivr.net/npm/compressorjs@1.1.1/dist/compressor.min.js"></script><script type="text/babel">const { useState, useReducer, useRef, useCallback, useEffect } = React;

      const initialState = {
        imageUrls: [],
        caption: "",
        loading: false,
        notification: "",
      };

      const reducer = (state, action) => {
        switch (action.type) {
          case "SET_IMAGE_URLS":
            return { ...state, imageUrls: action.payload };
          case "SET_CAPTION":
            return { ...state, caption: action.payload };
          case "SET_LOADING":
            return { ...state, loading: action.payload };
          case "SET_NOTIFICATION":
            return { ...state, notification: action.payload };
          default:
            return state;
        }
      };

      const App = () => {
        const [state, dispatch] = useReducer(reducer, initialState);
        const dragDropRef = useRef(null);

        const handleFileUpload = useCallback(
          (files) => {
            const validFiles = Array.from(files).filter((file) => file.type.startsWith("image/"));
            if (validFiles.length === 0) {
              showNotification("Only image files are supported.", "error");
              return;
            }

            const newImageUrlsPromises = validFiles.map(
              (file) =>
                new Promise((resolve, reject) => {
                  const reader = new FileReader();
                  reader.onload = async (e) => {
                    try {
                      const imageBitmap = await createImageBitmap(file);
                      const canvas = document.createElement("canvas");
                      canvas.width = imageBitmap.width;
                      canvas.height = imageBitmap.height;
                      const ctx = canvas.getContext("2d");
                      ctx.drawImage(imageBitmap, 0, 0);
                      resolve(canvas.toDataURL());
                    } catch (error) {
                      reject(error);
                    }
                  };
                  reader.readAsDataURL(file);
                })
            );

            Promise.all(newImageUrlsPromises)
              .then((newImageUrls) => dispatch({ type: "SET_IMAGE_URLS", payload: [...state.imageUrls, ...newImageUrls] }))
              .catch(() => showNotification("Error processing image.", "error"));
          },
          [state.imageUrls]
        );

        const handleDrop = useCallback(
          (e) => {
            e.preventDefault();
            e.stopPropagation();
            const files = e.dataTransfer.files;
            handleFileUpload(files);
            dragDropRef.current.classList.remove("dragover");
          },
          [handleFileUpload]
        );

        const handleDragOver = useCallback((e) => {
          e.preventDefault();
          e.stopPropagation();
          dragDropRef.current.classList.add("dragover");
        }, []);

        const handleDragLeave = useCallback((e) => {
          e.preventDefault();
          e.stopPropagation();
          dragDropRef.current.classList.remove("dragover");
        }, []);

        const showNotification = (message, type = "success") => {
          dispatch({ type: "SET_NOTIFICATION", payload: { message, type } });
          setTimeout(() => dispatch({ type: "SET_NOTIFICATION", payload: "" }), 5000);
        };

        const downloadImage = useCallback(async () => {
          if (state.imageUrls.length === 0) {
            showNotification("No images to process.", "error");
            return;
          }
          dispatch({ type: "SET_LOADING", payload: true });
          try {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            const imgCount = state.imageUrls.length;
            let imageWidth = 1200;
            let imageHeight = 628 * imgCount;
            canvas.width = imageWidth;
            canvas.height = imageHeight;

            const imageElements = state.imageUrls.map((src) => {
              const img = new Image();
              img.src = src;
              return new Promise((resolve) => {
                img.onload = () => resolve(img);
              });
            });

            const images = await Promise.all(imageElements);
            images.forEach((img, index) => {
              ctx.drawImage(img, 0, index * 628, imageWidth, 628);
            });

            ctx.font = "700 24px Arial";
            ctx.fillStyle = "#010642";
            ctx.globalAlpha = 0.77;
            const watermarkWidth = 150;
            const watermarkHeight = 36;
            const watermarkX = canvas.width - watermarkWidth - 10;
            const watermarkY = 10 + watermarkHeight / 2;
            ctx.beginPath();
            ctx.roundRect(watermarkX, 10, watermarkWidth, watermarkHeight, 50);
            ctx.fill();
            ctx.globalAlpha = 1;
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("Vvip Times", watermarkX + watermarkWidth / 2, watermarkY);

            // Add caption
            if (state.caption) {
              ctx.font = "500 22px Arial";
              ctx.fillStyle = "black";
              ctx.globalAlpha = 0.7;

              const textMetrics = ctx.measureText(state.caption);
              const textHeight = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent;
              const captionHeight = textHeight + 10;

              ctx.beginPath();
              ctx.roundRect(0, canvas.height - captionHeight - 0, canvas.width, captionHeight, 15);
              ctx.fill();
              ctx.globalAlpha = 1;
              ctx.fillStyle = "white";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              const textY = canvas.height - captionHeight / 2 - 0;
              ctx.fillText(state.caption, canvas.width / 2, textY);
            }

            canvas.toBlob(
              async (blob) => {
                const imageCount = state.imageUrls.length;
                const maxQuality = 0.95;
                const minQuality = 0.05;
                const qualityStep = 0.01;

                const sizeLimits = {
                  1: 50000, // 50KB
                  2: 70000, // 70KB
                  3: 100000, // 100KB
                  4: 110000, // 110KB
                  5: 120000, // 120KB
                  6: 125000, // 125KB
                  7: 130000, // 130KB
                  8: 135000, // 135KB
                  9: 140000, // 140KB
                  10: 150000, // 150KB
                };

                const targetSize = sizeLimits[imageCount] || 200000; // Default to 200KB if over 10 images

                const compressImageToFileSize = async (blob, maxSize, baseQuality) => {
                  let quality = baseQuality;
                  let compressedBlob = await compressImage(blob, quality);

                  while (compressedBlob.size > maxSize && quality > minQuality) {
                    quality -= qualityStep;
                    compressedBlob = await compressImage(blob, quality);
                  }

                  return compressedBlob;
                };

                const compressImage = (blob, quality) => {
                  return new Promise((resolve, reject) => {
                    new Compressor(blob, {
                      quality: quality,
                      mimeType: "image/webp",
                      success: resolve,
                      error: reject,
                    });
                  });
                };

                const adjustQualityForDimensions = (width, height, baseQuality) => {
                  const dimensionFactor = Math.sqrt(width * height) / 1000;
                  const aspectRatioFactor = width / height;
                  return Math.max(minQuality, baseQuality / dimensionFactor / aspectRatioFactor);
                };

                const getImageData = (imageBitmap) => {
                  const canvas = document.createElement("canvas");
                  canvas.width = imageBitmap.width;
                  canvas.height = imageBitmap.height;
                  const ctx = canvas.getContext("2d");
                  ctx.drawImage(imageBitmap, 0, 0);
                  return ctx.getImageData(0, 0, imageBitmap.width, imageBitmap.height);
                };

                const calculateEntropy = (imageData) => {
                  const histogram = new Array(256).fill(0);
                  const pixels = imageData.data;

                  for (let i = 0; i < pixels.length; i += 4) {
                    const gray = Math.round((pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3);
                    histogram[gray]++;
                  }

                  let entropy = 0;
                  const totalPixels = imageData.width * imageData.height;

                  for (let i = 0; i < 256; i++) {
                    if (histogram[i] > 0) {
                      const p = histogram[i] / totalPixels;
                      entropy -= p * Math.log2(p);
                    }
                  }

                  return entropy;
                };

                const determineOptimalQuality = (imageBitmap) => {
                  const imageData = getImageData(imageBitmap);
                  const entropy = calculateEntropy(imageData);
                  const baseQuality = maxQuality - entropy / 10;
                  return baseQuality;
                };

                const refineCompressionSettings = (quality, targetSize, baseQuality, dimensionFactor, aspectRatioFactor) => {
                  let adjustedQuality = baseQuality;
                  let iterations = 0;

                  while (adjustedQuality > minQuality && iterations < 10) {
                    const currentSize = dimensionFactor * aspectRatioFactor * adjustedQuality * 1000;
                    if (currentSize <= targetSize) break;

                    adjustedQuality -= qualityStep;
                    iterations++;
                  }

                  return adjustedQuality;
                };

                if ("OffscreenCanvas" in window && "ImageEncoder" in window) {
                  const offscreenCanvas = new OffscreenCanvas(canvas.width, canvas.height);
                  const offscreenCtx = offscreenCanvas.getContext("2d");
                  offscreenCtx.drawImage(canvas, 0, 0);

                  const imageBitmap = offscreenCanvas.transferToImageBitmap();
                  const baseQuality = determineOptimalQuality(imageBitmap);

                  const encoder = new ImageEncoder({
                    type: "image/webp",
                    quality: baseQuality,
                    mode: "lossy",
                  });

                  try {
                    let encodedBlob = await encoder.encode(imageBitmap);

                    if (encodedBlob.size > targetSize) {
                      encodedBlob = await compressImageToFileSize(encodedBlob, targetSize, baseQuality);
                    }

                    const url = URL.createObjectURL(encodedBlob);
                    const link = document.createElement("a");
                    link.href = url;
                    link.download = "combined_image.webp";
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                    showNotification("Image downloaded successfully.");
                  } catch (error) {
                    console.error("Error encoding image with ImageEncoder:", error);
                    showNotification("Error encoding image with ImageEncoder.", "error");
                  }
                } else {
                  const baseQuality = adjustQualityForDimensions(canvas.width, canvas.height, maxQuality);
                  const dimensionFactor = Math.sqrt(canvas.width * canvas.height) / 1000;
                  const aspectRatioFactor = canvas.width / canvas.height;
                  const refinedQuality = refineCompressionSettings(qualityStep, targetSize, baseQuality, dimensionFactor, aspectRatioFactor);

                  let compressedBlob = await compressImage(blob, refinedQuality);

                  if (compressedBlob.size > targetSize) {
                    compressedBlob = await compressImageToFileSize(compressedBlob, targetSize, refinedQuality);
                  }

                  const url = URL.createObjectURL(compressedBlob);
                  const link = document.createElement("a");
                  link.href = url;
                  link.download = "combined_image.webp";
                  document.body.appendChild(link);
                  link.click();
                  document.body.removeChild(link);
                  URL.revokeObjectURL(url);
                  showNotification("Image downloaded successfully.");
                }
              },
              "image/webp",
              1.0
            ); // Set maximum quality for toBlob
          } catch (error) {
            showNotification("Error creating the image.", "error");
          } finally {
            dispatch({ type: "SET_LOADING", payload: false });
          }
        }, [state.imageUrls, state.caption]);

        return (
          
			<div className="container">
				<h1>Vvip Times Multi Image Creator Pro ++</h1>
				<form onSubmit={(e) => e.preventDefault()}>
					<input type="text" placeholder="Enter caption" value={state.caption} onChange={(e) => dispatch({ type: "SET_CAPTION", payload: e.target.value })} />
					<div ref={dragDropRef} className="drag-drop-area" onDrop={handleDrop} onDragOver={handleDragOver} onDragLeave={handleDragLeave} onClick={() => dragDropRef.current.querySelector('input[type="file"]').click()}>
						<input type="file" accept="image/*" multiple onChange={(e) => handleFileUpload(e.target.files)} />
					</div>
					<button type="button" onClick={downloadImage}>
                Create Image
              </button>
					<br />
				</form>
            {state.loading && 
				<div className="loading-spinner"></div>}
            {state.notification && 
				<div className="notification">{state.notification.message}</div>}
            {state.imageUrls.length > 0 && (
              
				<div className="image-preview-container">
                {state.imageUrls.map((src, index) => (
                  
					<div key={index} className="image-wrapper">
						<img src={src} alt={`Uploaded preview ${index}`} />
						<button
                      className="remove-image-button"
                      onClick={() => {
                        const updatedUrls = state.imageUrls.filter((_, i) => i !== index);
                        dispatch({ type: "SET_IMAGE_URLS", payload: updatedUrls });
                      }}
                    >
                      &times;
                    </button>
					</div>
                ))}
              
				</div>
            )}
          
			</div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(
			<App />);</script></body></html>
