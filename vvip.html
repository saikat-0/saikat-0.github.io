<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background: #f0fff0;
            margin: 0;
            padding: 0;
            color: #333;
        }

        .container {
            max-width: 1160px;
            margin: auto;
            padding: 30px;
            text-align: center;
        }

        h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            color: navy;
        }

        form {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        input[type=text] {
            border: 2px dashed navy;
            border-radius: 8px;
            padding: 12px;
            width: 100%;
            max-width: auto;
            font-size: 1.4rem;
            text-align: center;
        }

        button {
        background: #4a0026f2;
        color: #fff;
        border: 10px solid #ff69b4;
        border-radius: 50px;
        padding: 9px;
        font-size: 1.5rem;
        cursor: pointer;
        transition: background .3s;
        width: 250px;
        max-width: 400px
      }

      button:hover {
        background: #08005df5;
        border: 10px solid #0071f9f0;
        color: #fff
      }

        .drag-drop-area {
            border: 2px dashed navy;
            border-radius: 12px;
            padding: 50px;
            min-height: 30vh;
            background: #fff;
            cursor: pointer;
            position: relative;
            margin: 20px 0;
            transition: border-color .3s, background .3s;
        }

        .drag-drop-area.dragover {
            border-color: #004d40;
            background: #b2dfdb;
        }

        .drag-drop-area::after {
            content: 'Drag & Drop Images Here';
            color: navy;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
        }

        .image-preview-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
        gap: 10px;
        background: #ff69b4;
        padding: 10px;
        border-radius: 12px
      }

        .image-wrapper {
            position: relative;
            width: 100%;
            height: 0;
            padding-top: 52%;
            overflow: hidden;
        }

        .image-wrapper img {
            position: absolute;
            top: 50%;
            left: 50%;
            width: auto;
            height: 100%;
            transform: translate(-50%, -50%);
        }

        .remove-image-button {
            position: absolute;
            top: 3px;
            right: 3px;
            background: rgba(0, 0, 0, .7);
            color: #fff;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.6rem;
            z-index: 1;
        }

        .remove-image-button:hover {
            background: rgba(0, 0, 0, .9);
        }

        .caption {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, .7);
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            text-align: center;
            width: calc(100% - 20px);
        }

        .watermark {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, .5);
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            text-align: center;
            z-index: 1;
        }

        .loading-spinner {
            border: 16px solid #f3f3f3;
            border-top: 16px solid #00796b;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        .notification {
            background: #00796b;
            color: #fff;
            padding: 15px;
            border-radius: 8px;
            margin: 20px auto;
            width: 90%;
            max-width: 400px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0);
            }
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>
<body>
<div id="root"></div>
<script src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/babel-standalone@6.26.0/babel.min.js"></script>
<script type="text/babel">
    const { useState, useRef, useCallback } = React;

const App = () => {
  const [imageUrls, setImageUrls] = useState([]);
  const [caption, setCaption] = useState('');
  const [loading, setLoading] = useState(false);
  const [notification, setNotification] = useState('');
  const dragDropRef = useRef(null);

  const handleFileUpload = useCallback((files) => {
    const newImageUrls = [];
    Array.from(files).forEach(file => {
      if (file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = (e) => {
          newImageUrls.push(e.target.result);
          setImageUrls(prev => [...prev, ...newImageUrls]);
        };
        reader.readAsDataURL(file);
      } else {
        showNotification('Only image files are supported.', 'error');
      }
    });
  }, []);

  const handleDrop = useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();
    handleFileUpload(e.dataTransfer.files);
    dragDropRef.current.classList.remove('dragover');
  }, [handleFileUpload]);

  const handleDragOver = useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();
    dragDropRef.current.classList.add('dragover');
  }, []);

  const handleDragLeave = useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();
    dragDropRef.current.classList.remove('dragover');
  }, []);

  const showNotification = (message, type = 'success') => {
    setNotification({ message, type });
    setTimeout(() => setNotification(''), 5000);
  };

  const compressImage = async (canvas) => {
  const maxFileSize = 50 * 1024; // 50 KB
  let quality = 1.0;
  let dataUrl = '';
  let compressedBlob = null;

  while (quality > 0) {
    dataUrl = canvas.toDataURL('image/webp', quality);
    compressedBlob = await fetch(dataUrl).then(res => res.blob());
    if (compressedBlob.size <= maxFileSize) break;
    quality -= 0.01; // Finer quality decrement
  }

  return dataUrl;
};

const downloadImage = useCallback(async () => {
  if (imageUrls.length === 0) {
    showNotification('No images to process.', 'error');
    return;
  }

  setLoading(true);
  try {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const imgCount = imageUrls.length;

    canvas.width = 1200;
    canvas.height = 628;

    const imageElements = imageUrls.map((src) => {
      const img = new Image();
      img.src = src;
      return new Promise((resolve) => {
        img.onload = () => resolve(img);
      });
    });

    const images = await Promise.all(imageElements);

    const layoutMap = [
      (ctx, images) => {
        ctx.drawImage(images[0], 0, 0, canvas.width, canvas.height);
      },
      (ctx, images) => {
        cropAndDrawImage(ctx, images[0], 0, 0, canvas.width / 2, canvas.height);
        cropAndDrawImage(ctx, images[1], canvas.width / 2, 0, canvas.width / 2, canvas.height);
      },
      (ctx, images) => {
        cropAndDrawImage(ctx, images[0], 0, 0, canvas.width / 2, canvas.height / 2);
        cropAndDrawImage(ctx, images[1], canvas.width / 2, 0, canvas.width / 2, canvas.height / 2);
        cropAndDrawImage(ctx, images[2], 0, canvas.height / 2, canvas.width, canvas.height / 2);
      },
      (ctx, images) => {
        cropAndDrawImage(ctx, images[0], 0, 0, canvas.width / 2, canvas.height / 2);
        cropAndDrawImage(ctx, images[1], canvas.width / 2, 0, canvas.width / 2, canvas.height / 2);
        cropAndDrawImage(ctx, images[2], 0, canvas.height / 2, canvas.width / 2, canvas.height / 2);
        cropAndDrawImage(ctx, images[3], canvas.width / 2, canvas.height / 2, canvas.width / 2, canvas.height / 2);
      }
    ];

    layoutMap[Math.min(imgCount, 4) - 1](ctx, images);

   // Add watermark
ctx.font = '700 24px Arial';
ctx.fillStyle = '#010642';
ctx.globalAlpha = 0.77;
const watermarkPadding = 10;
const watermarkWidth = 148;
const watermarkHeight = 36;
ctx.beginPath();
ctx.roundRect(canvas.width - watermarkWidth - watermarkPadding, watermarkPadding, watermarkWidth, watermarkHeight, 50);
ctx.fill();
ctx.globalAlpha = 1;
ctx.fillStyle = 'white';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
const watermarkX = canvas.width - (watermarkWidth / 2) - watermarkPadding;
const watermarkY = watermarkPadding + (watermarkHeight / 2);
ctx.fillText('VVIP Times', watermarkX, watermarkY);

// Add caption
if (caption) {
  ctx.font = '500 20px Arial';
  ctx.fillStyle = 'black';
  ctx.globalAlpha = 0.5;
  const textMetrics = ctx.measureText(caption);
  const captionHeight = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent + 10;
  const captionPadding = 10;
  
  // Draw the caption background with border-radius of 50px
  ctx.globalAlpha = 0.5;
  ctx.beginPath();
  ctx.roundRect(0, canvas.height - captionHeight - captionPadding, canvas.width, captionHeight + captionPadding, 50);
  ctx.fill();
  
  // Draw the caption text
  ctx.globalAlpha = 1;
  ctx.fillStyle = 'white';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const captionX = canvas.width / 2;
  const captionY = canvas.height - (captionHeight / 2) - captionPadding / 2;
  ctx.fillText(caption, captionX, captionY);
}




    const compressedDataUrl = await compressImage(canvas);
    const link = document.createElement('a');
    link.href = compressedDataUrl;
    link.download = 'VvipTimes_.webp';
    link.click();
    showNotification('Image collage created and downloaded!');
  } catch (error) {
    showNotification('Error creating image collage.', 'error');
  } finally {
    setLoading(false);
  }
}, [imageUrls, caption]);

const cropAndDrawImage = (ctx, img, x, y, width, height) => {
  const imgAspectRatio = img.width / img.height;
  const canvasAspectRatio = width / height;
  
  let sx, sy, swidth, sheight;

  if (imgAspectRatio > canvasAspectRatio) {
    // Image is wider than canvas aspect ratio
    sheight = img.height;
    swidth = img.height * canvasAspectRatio;
    sx = (img.width - swidth) / 2;
    sy = 0;
  } else {
    // Image is taller than canvas aspect ratio
    swidth = img.width;
    sheight = img.width / canvasAspectRatio;
    sx = 0;
    sy = (img.height - sheight) / 2;
  }

  ctx.drawImage(img, sx, sy, swidth, sheight, x, y, width, height);
};


const removeImage = (index) => {
  const newImageUrls = [...imageUrls];
  newImageUrls.splice(index, 1);
  setImageUrls(newImageUrls);
};


  return (
    <div className="container">
      <h1>Image Collage Creator</h1>
      <input
        type="file"
        accept="image/*"
        multiple
        onChange={(e) => handleFileUpload(e.target.files)}
      />
      <div
        className="drag-drop-area"
        ref={dragDropRef}
        onDrop={handleDrop}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
      ></div>
      <input
        type="text"
        placeholder="Enter a caption (optional)"
        value={caption}
        onChange={(e) => setCaption(e.target.value)}
      /><br /><br />
      <button onClick={downloadImage}>Download Image</button><br /><br />
      {loading && <div className="loading-spinner"></div>}
      {notification && (
        <div className={`notification ${notification.type}`}>
          {notification.message}
        </div>
      )}
      <div className="image-preview-container">
        {imageUrls.map((url, index) => (
          <div className="image-wrapper" key={index}>
            <img src={url} alt={`Image ${index + 1}`} />
            <button
              className="remove-image-button"
              onClick={() => removeImage(index)}
            >
              &times;
            </button>
          </div>
        ))}
      </div>
    </div>
  );
};

ReactDOM.render(<App />, document.getElementById('root'));
</script>
</body>
</html>
